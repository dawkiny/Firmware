   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.process_hand_swap,"ax",@progbits
  11               	.global	process_hand_swap
  13               	process_hand_swap:
  14               	.LVL0:
  15               	.LFB107:
  16               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "backlight.h"
  24:tmk_core/common/action.c **** #include "action_layer.h"
  25:tmk_core/common/action.c **** #include "action_tapping.h"
  26:tmk_core/common/action.c **** #include "action_macro.h"
  27:tmk_core/common/action.c **** #include "action_util.h"
  28:tmk_core/common/action.c **** #include "action.h"
  29:tmk_core/common/action.c **** #include "wait.h"
  30:tmk_core/common/action.c **** 
  31:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:tmk_core/common/action.c **** #include "debug.h"
  33:tmk_core/common/action.c **** #else
  34:tmk_core/common/action.c **** #include "nodebug.h"
  35:tmk_core/common/action.c **** #endif
  36:tmk_core/common/action.c **** 
  37:tmk_core/common/action.c **** int tp_buttons;
  38:tmk_core/common/action.c **** 
  39:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:tmk_core/common/action.c **** #endif
  42:tmk_core/common/action.c **** 
  43:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:tmk_core/common/action.c **** #include <fauxclicky.h>
  45:tmk_core/common/action.c **** #endif
  46:tmk_core/common/action.c **** 
  47:tmk_core/common/action.c **** /** \brief Called to execute an action.
  48:tmk_core/common/action.c ****  *
  49:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  50:tmk_core/common/action.c ****  */
  51:tmk_core/common/action.c **** void action_exec(keyevent_t event)
  52:tmk_core/common/action.c **** {
  53:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  54:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  55:tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  56:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  57:tmk_core/common/action.c ****         retro_tapping_counter++;
  58:tmk_core/common/action.c **** #endif
  59:tmk_core/common/action.c ****     }
  60:tmk_core/common/action.c **** 
  61:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  62:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  63:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  64:tmk_core/common/action.c ****     }
  65:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  66:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  67:tmk_core/common/action.c ****     }
  68:tmk_core/common/action.c ****     fauxclicky_check();
  69:tmk_core/common/action.c **** #endif
  70:tmk_core/common/action.c **** 
  71:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  72:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  73:tmk_core/common/action.c ****         process_hand_swap(&event);
  74:tmk_core/common/action.c ****     }
  75:tmk_core/common/action.c **** #endif
  76:tmk_core/common/action.c **** 
  77:tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  78:tmk_core/common/action.c **** 
  79:tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  80:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  81:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  82:tmk_core/common/action.c ****     }
  83:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  84:tmk_core/common/action.c ****         clear_oneshot_mods();
  85:tmk_core/common/action.c ****     }
  86:tmk_core/common/action.c **** #endif
  87:tmk_core/common/action.c **** 
  88:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  89:tmk_core/common/action.c ****     action_tapping_process(record);
  90:tmk_core/common/action.c **** #else
  91:tmk_core/common/action.c ****     process_record(&record);
  92:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  93:tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
  94:tmk_core/common/action.c ****     }
  95:tmk_core/common/action.c **** #endif
  96:tmk_core/common/action.c **** }
  97:tmk_core/common/action.c **** 
  98:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  99:tmk_core/common/action.c **** bool swap_hands = false;
 100:tmk_core/common/action.c **** bool swap_held = false;
 101:tmk_core/common/action.c **** 
 102:tmk_core/common/action.c **** /** \brief Process Hand Swap
 103:tmk_core/common/action.c ****  *
 104:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 105:tmk_core/common/action.c ****  */
 106:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
  17               		.loc 1 106 43 view -0
  18               		.cfi_startproc
  19               		.loc 1 106 43 is_stmt 0 view .LVU1
  20 0000 CF93      		push r28
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 28, -2
  24 0002 DF93      		push r29
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 29, -3
  28               	/* prologue: function */
  29               	/* frame size = 0 */
  30               	/* stack size = 2 */
  31               	.L__stack_usage = 2
  32 0004 DC01      		movw r26,r24
 107:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
  33               		.loc 1 107 5 is_stmt 1 view .LVU2
 108:tmk_core/common/action.c **** 
 109:tmk_core/common/action.c ****     keypos_t pos = event->key;
  34               		.loc 1 109 5 view .LVU3
  35               	.LVL1:
 110:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1<<pos.col;
  36               		.loc 1 110 5 view .LVU4
  37               		.loc 1 110 56 is_stmt 0 view .LVU5
  38 0006 8C91      		ld r24,X
  39               	.LVL2:
  40               		.loc 1 110 56 view .LVU6
  41 0008 682F      		mov r22,r24
  42 000a 70E0      		ldi r23,0
  43               		.loc 1 110 51 view .LVU7
  44 000c 21E0      		ldi r18,lo8(1)
  45 000e 30E0      		ldi r19,0
  46 0010 00C0      		rjmp 2f
  47               		1:
  48 0012 220F      		lsl r18
  49               		2:
  50 0014 8A95      		dec r24
  51 0016 02F4      		brpl 1b
  52               	.LVL3:
 111:tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
  53               		.loc 1 111 5 is_stmt 1 view .LVU8
  54 0018 1196      		adiw r26,1
  55 001a 4C91      		ld r20,X
  56 001c 1197      		sbiw r26,1
  57 001e 50E0      		ldi r21,0
  58 0020 EA01      		movw r28,r20
  59 0022 C050      		subi r28,lo8(-(swap_state.4990))
  60 0024 D040      		sbci r29,hi8(-(swap_state.4990))
  61 0026 9881      		ld r25,Y
  62               		.loc 1 111 48 is_stmt 0 view .LVU9
  63 0028 1296      		adiw r26,2
  64 002a 8C91      		ld r24,X
  65 002c 1297      		sbiw r26,2
  66               	.LVL4:
  67               		.loc 1 111 48 view .LVU10
  68 002e 8823      		tst r24
  69 0030 01F0      		breq .L2
  70               		.loc 1 111 48 discriminator 1 view .LVU11
  71 0032 8091 0000 		lds r24,swap_hands
  72               	.LVL5:
 112:tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 113:tmk_core/common/action.c **** 
 114:tmk_core/common/action.c ****     if (do_swap) {
  73               		.loc 1 114 5 is_stmt 1 discriminator 1 view .LVU12
  74               	.L11:
 111:tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
  75               		.loc 1 111 48 is_stmt 0 discriminator 2 view .LVU13
  76 0036 8823      		tst r24
  77 0038 01F0      		breq .L5
 115:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
  78               		.loc 1 115 9 is_stmt 1 view .LVU14
  79               		.loc 1 115 20 is_stmt 0 view .LVU15
  80 003a 86E0      		ldi r24,lo8(6)
  81 003c 849F      		mul r24,r20
  82 003e F001      		movw r30,r0
  83 0040 859F      		mul r24,r21
  84 0042 F00D      		add r31,r0
  85 0044 1124      		clr __zero_reg__
  86 0046 E60F      		add r30,r22
  87 0048 F71F      		adc r31,r23
  88 004a EE0F      		lsl r30
  89 004c FF1F      		rol r31
  90 004e E050      		subi r30,lo8(-(hand_swap_config))
  91 0050 F040      		sbci r31,hi8(-(hand_swap_config))
  92 0052 4081      		ld r20,Z
  93 0054 5181      		ldd r21,Z+1
  94 0056 4D93      		st X+,r20
  95 0058 5C93      		st X,r21
  96               	.LVL6:
 116:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
  97               		.loc 1 116 9 is_stmt 1 view .LVU16
  98               		.loc 1 116 29 is_stmt 0 view .LVU17
  99 005a 292B      		or r18,r25
 100               	.LVL7:
 101               	.L12:
 117:tmk_core/common/action.c ****     } else {
 118:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 102               		.loc 1 118 29 view .LVU18
 103 005c 2883      		st Y,r18
 104               	.LVL8:
 105               	/* epilogue start */
 119:tmk_core/common/action.c ****     }
 120:tmk_core/common/action.c **** }
 106               		.loc 1 120 1 view .LVU19
 107 005e DF91      		pop r29
 108 0060 CF91      		pop r28
 109 0062 0895      		ret
 110               	.LVL9:
 111               	.L2:
 111:tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 112               		.loc 1 111 48 discriminator 2 view .LVU20
 113 0064 892F      		mov r24,r25
 114 0066 8223      		and r24,r18
 115 0068 00C0      		rjmp .L11
 116               	.L5:
 118:tmk_core/common/action.c ****     }
 117               		.loc 1 118 9 is_stmt 1 view .LVU21
 118:tmk_core/common/action.c ****     }
 118               		.loc 1 118 29 is_stmt 0 view .LVU22
 119 006a 2095      		com r18
 120               	.LVL10:
 118:tmk_core/common/action.c ****     }
 121               		.loc 1 118 29 view .LVU23
 122 006c 2923      		and r18,r25
 123 006e 00C0      		rjmp .L12
 124               		.cfi_endproc
 125               	.LFE107:
 127               		.section	.text.action_exec,"ax",@progbits
 128               	.global	action_exec
 130               	action_exec:
 131               	.LFB106:
  52:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
 132               		.loc 1 52 1 is_stmt 1 view -0
 133               		.cfi_startproc
 134 0000 CF93      		push r28
 135               	.LCFI2:
 136               		.cfi_def_cfa_offset 3
 137               		.cfi_offset 28, -2
 138 0002 DF93      		push r29
 139               	.LCFI3:
 140               		.cfi_def_cfa_offset 4
 141               		.cfi_offset 29, -3
 142 0004 CDB7      		in r28,__SP_L__
 143 0006 DEB7      		in r29,__SP_H__
 144               	.LCFI4:
 145               		.cfi_def_cfa_register 28
 146 0008 2B97      		sbiw r28,11
 147               	.LCFI5:
 148               		.cfi_def_cfa_offset 15
 149 000a 0FB6      		in __tmp_reg__,__SREG__
 150 000c F894      		cli
 151 000e DEBF      		out __SP_H__,r29
 152 0010 0FBE      		out __SREG__,__tmp_reg__
 153 0012 CDBF      		out __SP_L__,r28
 154               	/* prologue: function */
 155               	/* frame size = 11 */
 156               	/* stack size = 13 */
 157               	.L__stack_usage = 13
 158 0014 4F83      		std Y+7,r20
 159 0016 5887      		std Y+8,r21
 160 0018 6987      		std Y+9,r22
 161 001a 7A87      		std Y+10,r23
 162 001c 8B87      		std Y+11,r24
  53:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
 163               		.loc 1 53 5 view .LVU25
 164               	.LBB16:
 165               	.LBI16:
 166               		.file 2 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** 
  25:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:tmk_core/common/keyboard.h **** extern "C" {
  27:tmk_core/common/keyboard.h **** #endif
  28:tmk_core/common/keyboard.h **** 
  29:tmk_core/common/keyboard.h **** /* key matrix position */
  30:tmk_core/common/keyboard.h **** typedef struct {
  31:tmk_core/common/keyboard.h ****     uint8_t col;
  32:tmk_core/common/keyboard.h ****     uint8_t row;
  33:tmk_core/common/keyboard.h **** } keypos_t;
  34:tmk_core/common/keyboard.h **** 
  35:tmk_core/common/keyboard.h **** /* key event */
  36:tmk_core/common/keyboard.h **** typedef struct {
  37:tmk_core/common/keyboard.h ****     keypos_t key;
  38:tmk_core/common/keyboard.h ****     bool     pressed;
  39:tmk_core/common/keyboard.h ****     uint16_t time;
  40:tmk_core/common/keyboard.h **** } keyevent_t;
  41:tmk_core/common/keyboard.h **** 
  42:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:tmk_core/common/keyboard.h **** 
  45:tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:tmk_core/common/keyboard.h ****  */
  49:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 167               		.loc 2 49 20 view .LVU26
 168               	.LBB17:
 169               		.loc 2 49 51 view .LVU27
 170               		.loc 2 49 74 is_stmt 0 view .LVU28
 171 001e 8A85      		ldd r24,Y+10
 172 0020 9B85      		ldd r25,Y+11
 173 0022 892B      		or r24,r25
 174 0024 01F0      		breq .L14
 175 0026 CA01      		movw r24,r20
 176 0028 8923      		and r24,r25
 177 002a 8F3F      		cpi r24,lo8(-1)
 178 002c 01F4      		brne .L15
 179               	.L14:
 180               	.LBE17:
 181               	.LBE16:
  77:tmk_core/common/action.c **** 
 182               		.loc 1 77 5 is_stmt 1 view .LVU29
  77:tmk_core/common/action.c **** 
 183               		.loc 1 77 17 is_stmt 0 view .LVU30
 184 002e 1E82      		std Y+6,__zero_reg__
 185 0030 1D82      		std Y+5,__zero_reg__
 186 0032 85E0      		ldi r24,lo8(5)
 187 0034 FE01      		movw r30,r28
 188 0036 3796      		adiw r30,7
 189 0038 DE01      		movw r26,r28
 190 003a 1196      		adiw r26,1
 191               		0:
 192 003c 0190      		ld r0,Z+
 193 003e 0D92      		st X+,r0
 194 0040 8A95      		dec r24
 195 0042 01F4      		brne 0b
  89:tmk_core/common/action.c **** #else
 196               		.loc 1 89 5 is_stmt 1 view .LVU31
 197 0044 4981      		ldd r20,Y+1
 198 0046 5A81      		ldd r21,Y+2
 199 0048 6B81      		ldd r22,Y+3
 200 004a 7C81      		ldd r23,Y+4
 201 004c 8D81      		ldd r24,Y+5
 202 004e 9E81      		ldd r25,Y+6
 203 0050 0E94 0000 		call action_tapping_process
 204               	.LVL11:
 205               	/* epilogue start */
  96:tmk_core/common/action.c **** 
 206               		.loc 1 96 1 is_stmt 0 view .LVU32
 207 0054 2B96      		adiw r28,11
 208 0056 0FB6      		in __tmp_reg__,__SREG__
 209 0058 F894      		cli
 210 005a DEBF      		out __SP_H__,r29
 211 005c 0FBE      		out __SREG__,__tmp_reg__
 212 005e CDBF      		out __SP_L__,r28
 213 0060 DF91      		pop r29
 214 0062 CF91      		pop r28
 215 0064 0895      		ret
 216               	.L15:
  55:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
 217               		.loc 1 55 58 is_stmt 1 view .LVU33
  72:tmk_core/common/action.c ****         process_hand_swap(&event);
 218               		.loc 1 72 5 view .LVU34
  73:tmk_core/common/action.c ****     }
 219               		.loc 1 73 9 view .LVU35
 220 0066 CE01      		movw r24,r28
 221 0068 0796      		adiw r24,7
 222 006a 0E94 0000 		call process_hand_swap
 223               	.LVL12:
 224 006e 00C0      		rjmp .L14
 225               		.cfi_endproc
 226               	.LFE106:
 228               		.section	.text.process_record_quantum,"ax",@progbits
 229               		.weak	process_record_quantum
 231               	process_record_quantum:
 232               	.LVL13:
 233               	.LFB109:
 121:tmk_core/common/action.c **** #endif
 122:tmk_core/common/action.c **** 
 123:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 124:tmk_core/common/action.c **** bool disable_action_cache = false;
 125:tmk_core/common/action.c **** 
 126:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 127:tmk_core/common/action.c **** {
 128:tmk_core/common/action.c ****     disable_action_cache = true;
 129:tmk_core/common/action.c ****     process_record(record);
 130:tmk_core/common/action.c ****     disable_action_cache = false;
 131:tmk_core/common/action.c **** }
 132:tmk_core/common/action.c **** #else
 133:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 134:tmk_core/common/action.c **** {
 135:tmk_core/common/action.c ****     process_record(record);
 136:tmk_core/common/action.c **** }
 137:tmk_core/common/action.c **** #endif
 138:tmk_core/common/action.c **** 
 139:tmk_core/common/action.c **** __attribute__ ((weak))
 140:tmk_core/common/action.c **** bool process_record_quantum(keyrecord_t *record) {
 234               		.loc 1 140 50 view -0
 235               		.cfi_startproc
 236               	/* prologue: function */
 237               	/* frame size = 0 */
 238               	/* stack size = 0 */
 239               	.L__stack_usage = 0
 141:tmk_core/common/action.c ****     return true;
 240               		.loc 1 141 5 view .LVU37
 142:tmk_core/common/action.c **** }
 241               		.loc 1 142 1 is_stmt 0 view .LVU38
 242 0000 81E0      		ldi r24,lo8(1)
 243               	.LVL14:
 244               	/* epilogue start */
 245               		.loc 1 142 1 view .LVU39
 246 0002 0895      		ret
 247               		.cfi_endproc
 248               	.LFE109:
 250               		.section	.text.process_record_tap_hint,"ax",@progbits
 251               	.global	process_record_tap_hint
 253               	process_record_tap_hint:
 254               	.LVL15:
 255               	.LFB110:
 143:tmk_core/common/action.c **** 
 144:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 145:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 146:tmk_core/common/action.c ****  *
 147:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 148:tmk_core/common/action.c ****  */
 149:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record)
 150:tmk_core/common/action.c **** {
 256               		.loc 1 150 1 is_stmt 1 view -0
 257               		.cfi_startproc
 258               	/* prologue: function */
 259               	/* frame size = 0 */
 260               	/* stack size = 0 */
 261               	.L__stack_usage = 0
 151:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 262               		.loc 1 151 5 view .LVU41
 263               		.loc 1 151 23 is_stmt 0 view .LVU42
 264 0000 FC01      		movw r30,r24
 265 0002 8081      		ld r24,Z
 266 0004 9181      		ldd r25,Z+1
 267               	.LVL16:
 268               		.loc 1 151 23 view .LVU43
 269 0006 0E94 0000 		call layer_switch_get_action
 270               	.LVL17:
 152:tmk_core/common/action.c **** 
 153:tmk_core/common/action.c ****     switch (action.kind.id) {
 271               		.loc 1 153 5 is_stmt 1 view .LVU44
 272               		.loc 1 153 24 is_stmt 0 view .LVU45
 273 000a 9295      		swap r25
 274 000c 9F70      		andi r25,lo8(15)
 275               		.loc 1 153 5 view .LVU46
 276 000e 9630      		cpi r25,lo8(6)
 277 0010 01F4      		brne .L21
 154:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 155:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 156:tmk_core/common/action.c ****             switch (action.swap.code) {
 278               		.loc 1 156 13 is_stmt 1 view .LVU47
 157:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 158:tmk_core/common/action.c ****                 default:
 159:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 279               		.loc 1 159 21 view .LVU48
 280 0012 8091 0000 		lds r24,swap_hands
 281 0016 91E0      		ldi r25,lo8(1)
 282 0018 8927      		eor r24,r25
 283               		.loc 1 159 32 is_stmt 0 view .LVU49
 284 001a 8093 0000 		sts swap_hands,r24
 160:tmk_core/common/action.c ****                     swap_held = true;
 285               		.loc 1 160 21 is_stmt 1 view .LVU50
 286               		.loc 1 160 31 is_stmt 0 view .LVU51
 287 001e 9093 0000 		sts swap_held,r25
 161:tmk_core/common/action.c ****             }
 162:tmk_core/common/action.c ****             break;
 288               		.loc 1 162 13 is_stmt 1 view .LVU52
 289               	.L21:
 290               	/* epilogue start */
 163:tmk_core/common/action.c **** #endif
 164:tmk_core/common/action.c ****     }
 165:tmk_core/common/action.c **** }
 291               		.loc 1 165 1 is_stmt 0 view .LVU53
 292 0022 0895      		ret
 293               		.cfi_endproc
 294               	.LFE110:
 296               		.section	.text.register_code,"ax",@progbits
 297               	.global	register_code
 299               	register_code:
 300               	.LVL18:
 301               	.LFB113:
 166:tmk_core/common/action.c **** #endif
 167:tmk_core/common/action.c **** 
 168:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 169:tmk_core/common/action.c ****  *
 170:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 171:tmk_core/common/action.c ****  */
 172:tmk_core/common/action.c **** void process_record(keyrecord_t *record)
 173:tmk_core/common/action.c **** {
 174:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 175:tmk_core/common/action.c **** 
 176:tmk_core/common/action.c ****     if(!process_record_quantum(record))
 177:tmk_core/common/action.c ****         return;
 178:tmk_core/common/action.c **** 
 179:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 180:tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 181:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 182:tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 183:tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 184:tmk_core/common/action.c **** #endif
 185:tmk_core/common/action.c ****     dprintln();
 186:tmk_core/common/action.c **** 
 187:tmk_core/common/action.c ****     process_action(record, action);
 188:tmk_core/common/action.c **** }
 189:tmk_core/common/action.c **** 
 190:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 191:tmk_core/common/action.c ****  *
 192:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 193:tmk_core/common/action.c ****  */
 194:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action)
 195:tmk_core/common/action.c **** {
 196:tmk_core/common/action.c ****     keyevent_t event = record->event;
 197:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 198:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 199:tmk_core/common/action.c **** #endif
 200:tmk_core/common/action.c **** 
 201:tmk_core/common/action.c ****     if (event.pressed) {
 202:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 203:tmk_core/common/action.c ****         clear_weak_mods();
 204:tmk_core/common/action.c ****     }
 205:tmk_core/common/action.c **** 
 206:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 207:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 208:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 209:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 210:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 211:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 212:tmk_core/common/action.c ****     }
 213:tmk_core/common/action.c **** #endif
 214:tmk_core/common/action.c **** 
 215:tmk_core/common/action.c ****     switch (action.kind.id) {
 216:tmk_core/common/action.c ****         /* Key and Mods */
 217:tmk_core/common/action.c ****         case ACT_LMODS:
 218:tmk_core/common/action.c ****         case ACT_RMODS:
 219:tmk_core/common/action.c ****             {
 220:tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 221:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 222:tmk_core/common/action.c ****                 if (event.pressed) {
 223:tmk_core/common/action.c ****                     if (mods) {
 224:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 225:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 226:tmk_core/common/action.c ****                             // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSF
 227:tmk_core/common/action.c ****                             // Same applies for some keys like KC_MEH which are declared as MEH(KC_
 228:tmk_core/common/action.c ****                             add_mods(mods);
 229:tmk_core/common/action.c ****                         } else {
 230:tmk_core/common/action.c ****                             add_weak_mods(mods);
 231:tmk_core/common/action.c ****                         }
 232:tmk_core/common/action.c ****                         send_keyboard_report();
 233:tmk_core/common/action.c ****                     }
 234:tmk_core/common/action.c ****                     register_code(action.key.code);
 235:tmk_core/common/action.c ****                 } else {
 236:tmk_core/common/action.c ****                     unregister_code(action.key.code);
 237:tmk_core/common/action.c ****                     if (mods) {
 238:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 239:tmk_core/common/action.c ****                             del_mods(mods);
 240:tmk_core/common/action.c ****                         } else {
 241:tmk_core/common/action.c ****                             del_weak_mods(mods);
 242:tmk_core/common/action.c ****                         }
 243:tmk_core/common/action.c ****                         send_keyboard_report();
 244:tmk_core/common/action.c ****                     }
 245:tmk_core/common/action.c ****                 }
 246:tmk_core/common/action.c ****             }
 247:tmk_core/common/action.c ****             break;
 248:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 249:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 250:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 251:tmk_core/common/action.c ****             {
 252:tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 253:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 254:tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 255:tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 256:tmk_core/common/action.c ****                     case MODS_ONESHOT:
 257:tmk_core/common/action.c ****                         // Oneshot modifier
 258:tmk_core/common/action.c ****                         if (event.pressed) {
 259:tmk_core/common/action.c ****                             if (tap_count == 0) {
 260:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 261:tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 262:tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 263:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 264:tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 265:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 266:tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 267:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Toggling oneshot");
 268:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 269:tmk_core/common/action.c ****                                 set_oneshot_locked_mods(mods);
 270:tmk_core/common/action.c ****                                 register_mods(mods);
 271:tmk_core/common/action.c ****                     #endif
 272:tmk_core/common/action.c ****                             } else {
 273:tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 274:tmk_core/common/action.c ****                             }
 275:tmk_core/common/action.c ****                         } else {
 276:tmk_core/common/action.c ****                             if (tap_count == 0) {
 277:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 278:tmk_core/common/action.c ****                                 unregister_mods(mods);
 279:tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 280:tmk_core/common/action.c ****                                 // Retain Oneshot mods
 281:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 282:tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 283:tmk_core/common/action.c ****                                     clear_oneshot_locked_mods();
 284:tmk_core/common/action.c ****                                     clear_oneshot_mods();
 285:tmk_core/common/action.c ****                                     unregister_mods(mods);
 286:tmk_core/common/action.c ****                                 }
 287:tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 288:tmk_core/common/action.c ****                                 // Toggle Oneshot Layer
 289:tmk_core/common/action.c ****                     #endif
 290:tmk_core/common/action.c ****                             } else {
 291:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 292:tmk_core/common/action.c ****                                 unregister_mods(mods);
 293:tmk_core/common/action.c ****                             }
 294:tmk_core/common/action.c ****                         }
 295:tmk_core/common/action.c ****                         break;
 296:tmk_core/common/action.c ****     #endif
 297:tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 298:tmk_core/common/action.c ****                         if (event.pressed) {
 299:tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 300:tmk_core/common/action.c ****                                 register_mods(mods);
 301:tmk_core/common/action.c ****                             }
 302:tmk_core/common/action.c ****                         } else {
 303:tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 304:tmk_core/common/action.c ****                                 unregister_mods(mods);
 305:tmk_core/common/action.c ****                             }
 306:tmk_core/common/action.c ****                         }
 307:tmk_core/common/action.c ****                         break;
 308:tmk_core/common/action.c ****                     default:
 309:tmk_core/common/action.c ****                         if (event.pressed) {
 310:tmk_core/common/action.c ****                             if (tap_count > 0) {
 311:tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 312:tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 313:tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 314:tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 315:tmk_core/common/action.c ****                                     record->tap.count = 0;
 316:tmk_core/common/action.c ****                                     register_mods(mods);
 317:tmk_core/common/action.c ****                                 } else
 318:tmk_core/common/action.c **** #endif
 319:tmk_core/common/action.c ****                                 {
 320:tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 321:tmk_core/common/action.c ****                                     register_code(action.key.code);
 322:tmk_core/common/action.c ****                                 }
 323:tmk_core/common/action.c ****                             } else {
 324:tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 325:tmk_core/common/action.c ****                                 register_mods(mods);
 326:tmk_core/common/action.c ****                             }
 327:tmk_core/common/action.c ****                         } else {
 328:tmk_core/common/action.c ****                             if (tap_count > 0) {
 329:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 330:tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 331:tmk_core/common/action.c ****                             } else {
 332:tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 333:tmk_core/common/action.c ****                                 unregister_mods(mods);
 334:tmk_core/common/action.c ****                             }
 335:tmk_core/common/action.c ****                         }
 336:tmk_core/common/action.c ****                         break;
 337:tmk_core/common/action.c ****                 }
 338:tmk_core/common/action.c ****             }
 339:tmk_core/common/action.c ****             break;
 340:tmk_core/common/action.c **** #endif
 341:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 342:tmk_core/common/action.c ****         /* other HID usage */
 343:tmk_core/common/action.c ****         case ACT_USAGE:
 344:tmk_core/common/action.c ****             switch (action.usage.page) {
 345:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 346:tmk_core/common/action.c ****                     if (event.pressed) {
 347:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 348:tmk_core/common/action.c ****                     } else {
 349:tmk_core/common/action.c ****                         host_system_send(0);
 350:tmk_core/common/action.c ****                     }
 351:tmk_core/common/action.c ****                     break;
 352:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 353:tmk_core/common/action.c ****                     if (event.pressed) {
 354:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 355:tmk_core/common/action.c ****                     } else {
 356:tmk_core/common/action.c ****                         host_consumer_send(0);
 357:tmk_core/common/action.c ****                     }
 358:tmk_core/common/action.c ****                     break;
 359:tmk_core/common/action.c ****             }
 360:tmk_core/common/action.c ****             break;
 361:tmk_core/common/action.c **** #endif
 362:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 363:tmk_core/common/action.c ****         /* Mouse key */
 364:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 365:tmk_core/common/action.c ****             if (event.pressed) {
 366:tmk_core/common/action.c ****                 switch (action.key.code) {
 367:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 368:tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 369:tmk_core/common/action.c ****                         break;
 370:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 371:tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 372:tmk_core/common/action.c ****                         break;
 373:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 374:tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 375:tmk_core/common/action.c ****                         break;
 376:tmk_core/common/action.c ****                     default:
 377:tmk_core/common/action.c ****                         break;
 378:tmk_core/common/action.c ****                 }
 379:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 380:tmk_core/common/action.c ****                 mousekey_send();
 381:tmk_core/common/action.c ****             } else {
 382:tmk_core/common/action.c ****                 switch (action.key.code) {
 383:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 384:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 385:tmk_core/common/action.c ****                         break;
 386:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 387:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 388:tmk_core/common/action.c ****                         break;
 389:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 390:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 391:tmk_core/common/action.c ****                         break;
 392:tmk_core/common/action.c ****                     default:
 393:tmk_core/common/action.c ****                         break;
 394:tmk_core/common/action.c ****                 }
 395:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 396:tmk_core/common/action.c ****                 mousekey_send();
 397:tmk_core/common/action.c ****             }
 398:tmk_core/common/action.c ****             break;
 399:tmk_core/common/action.c **** #endif
 400:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 401:tmk_core/common/action.c ****         case ACT_LAYER:
 402:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 403:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 404:tmk_core/common/action.c ****                 if (!event.pressed) {
 405:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 406:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 407:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 408:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 409:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 410:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 411:tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 412:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 413:tmk_core/common/action.c ****                     }
 414:tmk_core/common/action.c ****                 }
 415:tmk_core/common/action.c ****             } else {
 416:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 417:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 418:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 419:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 420:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 421:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 422:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 423:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 424:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 425:tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 426:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 427:tmk_core/common/action.c ****                     }
 428:tmk_core/common/action.c ****                 }
 429:tmk_core/common/action.c ****             }
 430:tmk_core/common/action.c ****             break;
 431:tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 432:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 433:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 434:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 435:tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 436:tmk_core/common/action.c ****                     /* layer On/Off with modifiers(left only) */
 437:tmk_core/common/action.c ****                     if (event.pressed) {
 438:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 439:tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 440:tmk_core/common/action.c ****                     } else {
 441:tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 442:tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 443:tmk_core/common/action.c ****                     }
 444:tmk_core/common/action.c ****                     break;
 445:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 446:tmk_core/common/action.c ****                     /* tap toggle */
 447:tmk_core/common/action.c ****                     if (event.pressed) {
 448:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 449:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 450:tmk_core/common/action.c ****                         }
 451:tmk_core/common/action.c ****                     } else {
 452:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 453:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 454:tmk_core/common/action.c ****                         }
 455:tmk_core/common/action.c ****                     }
 456:tmk_core/common/action.c ****                     break;
 457:tmk_core/common/action.c ****                 case OP_ON_OFF:
 458:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 459:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 460:tmk_core/common/action.c ****                     break;
 461:tmk_core/common/action.c ****                 case OP_OFF_ON:
 462:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 463:tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 464:tmk_core/common/action.c ****                     break;
 465:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 466:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 467:tmk_core/common/action.c ****                                     layer_clear();
 468:tmk_core/common/action.c ****                     break;
 469:tmk_core/common/action.c ****             #ifndef NO_ACTION_ONESHOT
 470:tmk_core/common/action.c ****                 case OP_ONESHOT:
 471:tmk_core/common/action.c ****                     // Oneshot modifier
 472:tmk_core/common/action.c ****                 #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 473:tmk_core/common/action.c ****                     do_release_oneshot = false;
 474:tmk_core/common/action.c ****                     if (event.pressed) {
 475:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 476:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 477:tmk_core/common/action.c ****                             reset_oneshot_layer();
 478:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 479:tmk_core/common/action.c ****                             break;
 480:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 481:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 482:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 483:tmk_core/common/action.c ****                         }
 484:tmk_core/common/action.c ****                     } else {
 485:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 486:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 487:tmk_core/common/action.c ****                             reset_oneshot_layer();
 488:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 489:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 490:tmk_core/common/action.c ****                         } else {
 491:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 492:tmk_core/common/action.c ****                         }
 493:tmk_core/common/action.c ****                     }
 494:tmk_core/common/action.c ****                 #else
 495:tmk_core/common/action.c ****                     if (event.pressed) {
 496:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 497:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 498:tmk_core/common/action.c ****                     } else {
 499:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 500:tmk_core/common/action.c ****                         if (tap_count > 1) {
 501:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 502:tmk_core/common/action.c ****                         }
 503:tmk_core/common/action.c ****                     }
 504:tmk_core/common/action.c ****                 #endif
 505:tmk_core/common/action.c ****                     break;
 506:tmk_core/common/action.c ****             #endif
 507:tmk_core/common/action.c ****                 default:
 508:tmk_core/common/action.c ****                     /* tap key */
 509:tmk_core/common/action.c ****                     if (event.pressed) {
 510:tmk_core/common/action.c ****                         if (tap_count > 0) {
 511:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 512:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 513:tmk_core/common/action.c ****                         } else {
 514:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 515:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 516:tmk_core/common/action.c ****                         }
 517:tmk_core/common/action.c ****                     } else {
 518:tmk_core/common/action.c ****                         if (tap_count > 0) {
 519:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 520:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 521:tmk_core/common/action.c ****                                 wait_ms(80);
 522:tmk_core/common/action.c ****                             }
 523:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 524:tmk_core/common/action.c ****                         } else {
 525:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 526:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 527:tmk_core/common/action.c ****                         }
 528:tmk_core/common/action.c ****                     }
 529:tmk_core/common/action.c ****                     break;
 530:tmk_core/common/action.c ****             }
 531:tmk_core/common/action.c ****             break;
 532:tmk_core/common/action.c ****     #endif
 533:tmk_core/common/action.c **** #endif
 534:tmk_core/common/action.c ****         /* Extentions */
 535:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 536:tmk_core/common/action.c ****         case ACT_MACRO:
 537:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 538:tmk_core/common/action.c ****             break;
 539:tmk_core/common/action.c **** #endif
 540:tmk_core/common/action.c **** #if defined(BACKLIGHT_ENABLE) | defined(LED_MATRIX_ENABLE)
 541:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 542:tmk_core/common/action.c ****             if (!event.pressed) {
 543:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 544:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 545:tmk_core/common/action.c ****                         backlight_increase();
 546:tmk_core/common/action.c ****                         break;
 547:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 548:tmk_core/common/action.c ****                         backlight_decrease();
 549:tmk_core/common/action.c ****                         break;
 550:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 551:tmk_core/common/action.c ****                         backlight_toggle();
 552:tmk_core/common/action.c ****                         break;
 553:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 554:tmk_core/common/action.c ****                         backlight_step();
 555:tmk_core/common/action.c ****                         break;
 556:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 557:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 558:tmk_core/common/action.c ****                         break;
 559:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 560:tmk_core/common/action.c ****                         backlight_level(0);
 561:tmk_core/common/action.c ****                         break;
 562:tmk_core/common/action.c ****                 }
 563:tmk_core/common/action.c ****             }
 564:tmk_core/common/action.c ****             break;
 565:tmk_core/common/action.c **** #endif
 566:tmk_core/common/action.c ****         case ACT_COMMAND:
 567:tmk_core/common/action.c ****             break;
 568:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 569:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 570:tmk_core/common/action.c ****             switch (action.swap.code) {
 571:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 572:tmk_core/common/action.c ****                     if (event.pressed) {
 573:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 574:tmk_core/common/action.c ****                     }
 575:tmk_core/common/action.c ****                     break;
 576:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 577:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 578:tmk_core/common/action.c ****                     break;
 579:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 580:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 581:tmk_core/common/action.c ****                     break;
 582:tmk_core/common/action.c ****                 case OP_SH_ON:
 583:tmk_core/common/action.c ****                     if (!event.pressed) {
 584:tmk_core/common/action.c ****                         swap_hands = true;
 585:tmk_core/common/action.c ****                     }
 586:tmk_core/common/action.c ****                     break;
 587:tmk_core/common/action.c ****                 case OP_SH_OFF:
 588:tmk_core/common/action.c ****                     if (!event.pressed) {
 589:tmk_core/common/action.c ****                         swap_hands = false;
 590:tmk_core/common/action.c ****                     }
 591:tmk_core/common/action.c ****                     break;
 592:tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 593:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 594:tmk_core/common/action.c ****                     /* tap toggle */
 595:tmk_core/common/action.c **** 
 596:tmk_core/common/action.c ****                     if (event.pressed) {
 597:tmk_core/common/action.c ****                         if (swap_held) {
 598:tmk_core/common/action.c ****                             swap_held = false;
 599:tmk_core/common/action.c ****                         } else {
 600:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 601:tmk_core/common/action.c ****                         }
 602:tmk_core/common/action.c ****                     } else {
 603:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 604:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 605:tmk_core/common/action.c ****                         }
 606:tmk_core/common/action.c ****                     }
 607:tmk_core/common/action.c ****                     break;
 608:tmk_core/common/action.c ****                 default:
 609:tmk_core/common/action.c ****                     /* tap key */
 610:tmk_core/common/action.c ****                     if (tap_count > 0) {
 611:tmk_core/common/action.c ****                         if (swap_held) {
 612:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 613:tmk_core/common/action.c ****                             swap_held = false;
 614:tmk_core/common/action.c ****                         }
 615:tmk_core/common/action.c ****                         if (event.pressed) {
 616:tmk_core/common/action.c ****                             register_code(action.swap.code);
 617:tmk_core/common/action.c ****                         } else {
 618:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 619:tmk_core/common/action.c ****                             *record = (keyrecord_t){}; // hack: reset tap mode
 620:tmk_core/common/action.c ****                         }
 621:tmk_core/common/action.c ****                     } else {
 622:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 623:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 624:tmk_core/common/action.c ****                             swap_held = false;
 625:tmk_core/common/action.c ****                         }
 626:tmk_core/common/action.c ****                     }
 627:tmk_core/common/action.c ****     #endif
 628:tmk_core/common/action.c ****             }
 629:tmk_core/common/action.c **** #endif
 630:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 631:tmk_core/common/action.c ****         case ACT_FUNCTION:
 632:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 633:tmk_core/common/action.c ****             break;
 634:tmk_core/common/action.c **** #endif
 635:tmk_core/common/action.c ****         default:
 636:tmk_core/common/action.c ****             break;
 637:tmk_core/common/action.c ****     }
 638:tmk_core/common/action.c **** 
 639:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 640:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 641:tmk_core/common/action.c ****     switch (action.kind.id) {
 642:tmk_core/common/action.c ****         case ACT_LAYER:
 643:tmk_core/common/action.c ****         #ifndef NO_ACTION_TAPPING
 644:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 645:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 646:tmk_core/common/action.c ****         #endif
 647:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 648:tmk_core/common/action.c ****             break;
 649:tmk_core/common/action.c ****         default:
 650:tmk_core/common/action.c ****             break;
 651:tmk_core/common/action.c ****     }
 652:tmk_core/common/action.c **** #endif
 653:tmk_core/common/action.c **** 
 654:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 655:tmk_core/common/action.c ****   #ifdef RETRO_TAPPING
 656:tmk_core/common/action.c ****   if (!is_tap_action(action)) {
 657:tmk_core/common/action.c ****     retro_tapping_counter = 0;
 658:tmk_core/common/action.c ****   } else {
 659:tmk_core/common/action.c ****     if (event.pressed) {
 660:tmk_core/common/action.c ****         if (tap_count > 0) {
 661:tmk_core/common/action.c ****           retro_tapping_counter = 0;
 662:tmk_core/common/action.c ****         } else {
 663:tmk_core/common/action.c **** 
 664:tmk_core/common/action.c ****         }
 665:tmk_core/common/action.c ****     } else {
 666:tmk_core/common/action.c ****       if (tap_count > 0) {
 667:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 668:tmk_core/common/action.c ****       } else {
 669:tmk_core/common/action.c ****         if (retro_tapping_counter == 2) {
 670:tmk_core/common/action.c ****           register_code(action.layer_tap.code);
 671:tmk_core/common/action.c ****           unregister_code(action.layer_tap.code);
 672:tmk_core/common/action.c ****         }
 673:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 674:tmk_core/common/action.c ****       }
 675:tmk_core/common/action.c ****     }
 676:tmk_core/common/action.c ****   }
 677:tmk_core/common/action.c ****   #endif
 678:tmk_core/common/action.c **** #endif
 679:tmk_core/common/action.c **** 
 680:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 681:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 682:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 683:tmk_core/common/action.c ****      */
 684:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 685:tmk_core/common/action.c ****         record->event.pressed = false;
 686:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 687:tmk_core/common/action.c ****         process_record(record);
 688:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 689:tmk_core/common/action.c ****     }
 690:tmk_core/common/action.c **** #endif
 691:tmk_core/common/action.c **** }
 692:tmk_core/common/action.c **** 
 693:tmk_core/common/action.c **** 
 694:tmk_core/common/action.c **** 
 695:tmk_core/common/action.c **** 
 696:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 697:tmk_core/common/action.c ****  *
 698:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 699:tmk_core/common/action.c ****  */
 700:tmk_core/common/action.c **** void register_code(uint8_t code)
 701:tmk_core/common/action.c **** {
 302               		.loc 1 701 1 is_stmt 1 view -0
 303               		.cfi_startproc
 304               		.loc 1 701 1 is_stmt 0 view .LVU55
 305 0000 CF93      		push r28
 306               	.LCFI6:
 307               		.cfi_def_cfa_offset 3
 308               		.cfi_offset 28, -2
 309               	/* prologue: function */
 310               	/* frame size = 0 */
 311               	/* stack size = 1 */
 312               	.L__stack_usage = 1
 313 0002 C82F      		mov r28,r24
 702:tmk_core/common/action.c ****     if (code == KC_NO) {
 314               		.loc 1 702 5 is_stmt 1 view .LVU56
 315               		.loc 1 702 8 is_stmt 0 view .LVU57
 316 0004 8823      		tst r24
 317 0006 01F4      		brne .+2
 318 0008 00C0      		rjmp .L23
 703:tmk_core/common/action.c ****         return;
 704:tmk_core/common/action.c ****     }
 705:tmk_core/common/action.c **** 
 706:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 707:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 319               		.loc 1 707 10 is_stmt 1 view .LVU58
 320               		.loc 1 707 13 is_stmt 0 view .LVU59
 321 000a 8238      		cpi r24,lo8(-126)
 322 000c 01F4      		brne .L26
 708:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 709:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 710:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 323               		.loc 1 710 9 is_stmt 1 view .LVU60
 324               		.loc 1 710 13 is_stmt 0 view .LVU61
 325 000e 0E94 0000 		call host_keyboard_leds
 326               	.LVL19:
 327               		.loc 1 710 12 view .LVU62
 328 0012 81FD      		sbrc r24,1
 329 0014 00C0      		rjmp .L23
 711:tmk_core/common/action.c **** #endif
 712:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 330               		.loc 1 712 9 is_stmt 1 view .LVU63
 331 0016 89E3      		ldi r24,lo8(57)
 332 0018 0E94 0000 		call add_key
 333               	.LVL20:
 713:tmk_core/common/action.c ****         send_keyboard_report();
 334               		.loc 1 713 9 view .LVU64
 335 001c 0E94 0000 		call send_keyboard_report
 336               	.LVL21:
 714:tmk_core/common/action.c ****         wait_ms(100);
 337               		.loc 1 714 9 view .LVU65
 338               	.LBB18:
 339               	.LBI18:
 340               		.file 3 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 341               		.loc 3 166 1 view .LVU66
 342               	.LBB19:
 167:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	double __tmp ;
 343               		.loc 3 168 2 view .LVU67
 169:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 344               		.loc 3 172 2 view .LVU68
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 345               		.loc 3 173 2 view .LVU69
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 346               		.loc 3 174 2 view .LVU70
 175:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 347               		.loc 3 184 3 view .LVU71
 185:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 348               		.loc 3 187 2 view .LVU72
 349 0020 2FEF      		ldi r18,lo8(319999)
 350 0022 81EE      		ldi r24,hi8(319999)
 351 0024 94E0      		ldi r25,hlo8(319999)
 352 0026 2150      	1:	subi r18,1
 353 0028 8040      		sbci r24,0
 354 002a 9040      		sbci r25,0
 355 002c 01F4      		brne 1b
 356 002e 00C0      		rjmp .
 357 0030 0000      		nop
 358               	.LVL22:
 359               		.loc 3 187 2 is_stmt 0 view .LVU73
 360               	.LBE19:
 361               	.LBE18:
 715:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 362               		.loc 1 715 9 is_stmt 1 view .LVU74
 363 0032 89E3      		ldi r24,lo8(57)
 364               	.L61:
 716:tmk_core/common/action.c ****         send_keyboard_report();
 717:tmk_core/common/action.c ****     }
 718:tmk_core/common/action.c **** 
 719:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 720:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 721:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 722:tmk_core/common/action.c **** #endif
 723:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 724:tmk_core/common/action.c ****         send_keyboard_report();
 725:tmk_core/common/action.c ****         wait_ms(100);
 726:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 365               		.loc 1 726 9 is_stmt 0 view .LVU75
 366 0034 0E94 0000 		call del_key
 367               	.LVL23:
 368               	.L62:
 727:tmk_core/common/action.c ****         send_keyboard_report();
 369               		.loc 1 727 9 is_stmt 1 view .LVU76
 370               	/* epilogue start */
 728:tmk_core/common/action.c ****     }
 729:tmk_core/common/action.c **** 
 730:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 731:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 732:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 733:tmk_core/common/action.c **** #endif
 734:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 735:tmk_core/common/action.c ****         send_keyboard_report();
 736:tmk_core/common/action.c ****         wait_ms(100);
 737:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 738:tmk_core/common/action.c ****         send_keyboard_report();
 739:tmk_core/common/action.c ****     }
 740:tmk_core/common/action.c **** #endif
 741:tmk_core/common/action.c **** 
 742:tmk_core/common/action.c ****     else if IS_KEY(code) {
 743:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 744:tmk_core/common/action.c ****         if (command_proc(code)) return;
 745:tmk_core/common/action.c **** 
 746:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 747:tmk_core/common/action.c **** /* TODO: remove
 748:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 749:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 750:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 751:tmk_core/common/action.c **** 
 752:tmk_core/common/action.c ****             add_key(code);
 753:tmk_core/common/action.c ****             send_keyboard_report();
 754:tmk_core/common/action.c **** 
 755:tmk_core/common/action.c ****             set_mods(tmp_mods);
 756:tmk_core/common/action.c ****             send_keyboard_report();
 757:tmk_core/common/action.c ****             oneshot_cancel();
 758:tmk_core/common/action.c ****         } else
 759:tmk_core/common/action.c **** */
 760:tmk_core/common/action.c **** #endif
 761:tmk_core/common/action.c ****         {
 762:tmk_core/common/action.c ****             add_key(code);
 763:tmk_core/common/action.c ****             send_keyboard_report();
 764:tmk_core/common/action.c ****         }
 765:tmk_core/common/action.c ****     }
 766:tmk_core/common/action.c ****     else if IS_MOD(code) {
 767:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 768:tmk_core/common/action.c ****         send_keyboard_report();
 769:tmk_core/common/action.c ****     }
 770:tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 771:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 772:tmk_core/common/action.c ****     }
 773:tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 774:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 775:tmk_core/common/action.c ****     }
 776:tmk_core/common/action.c **** 
 777:tmk_core/common/action.c ****     #ifdef MOUSEKEY_ENABLE
 778:tmk_core/common/action.c ****       else if IS_MOUSEKEY(code) {
 779:tmk_core/common/action.c ****         mousekey_on(code);
 780:tmk_core/common/action.c ****         mousekey_send();
 781:tmk_core/common/action.c ****       }
 782:tmk_core/common/action.c ****     #endif
 783:tmk_core/common/action.c **** }
 371               		.loc 1 783 1 is_stmt 0 view .LVU77
 372 0038 CF91      		pop r28
 727:tmk_core/common/action.c ****         send_keyboard_report();
 373               		.loc 1 727 9 view .LVU78
 374 003a 0C94 0000 		jmp send_keyboard_report
 375               	.LVL24:
 376               	.L26:
 719:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 377               		.loc 1 719 10 is_stmt 1 view .LVU79
 719:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 378               		.loc 1 719 13 is_stmt 0 view .LVU80
 379 003e 8338      		cpi r24,lo8(-125)
 380 0040 01F4      		brne .L28
 721:tmk_core/common/action.c **** #endif
 381               		.loc 1 721 9 is_stmt 1 view .LVU81
 721:tmk_core/common/action.c **** #endif
 382               		.loc 1 721 13 is_stmt 0 view .LVU82
 383 0042 0E94 0000 		call host_keyboard_leds
 384               	.LVL25:
 721:tmk_core/common/action.c **** #endif
 385               		.loc 1 721 12 view .LVU83
 386 0046 80FD      		sbrc r24,0
 387 0048 00C0      		rjmp .L23
 723:tmk_core/common/action.c ****         send_keyboard_report();
 388               		.loc 1 723 9 is_stmt 1 view .LVU84
 389 004a 83E5      		ldi r24,lo8(83)
 390 004c 0E94 0000 		call add_key
 391               	.LVL26:
 724:tmk_core/common/action.c ****         wait_ms(100);
 392               		.loc 1 724 9 view .LVU85
 393 0050 0E94 0000 		call send_keyboard_report
 394               	.LVL27:
 725:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 395               		.loc 1 725 9 view .LVU86
 396               	.LBB20:
 397               	.LBI20:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 398               		.loc 3 166 1 view .LVU87
 399               	.LBB21:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 400               		.loc 3 168 2 view .LVU88
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 401               		.loc 3 172 2 view .LVU89
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 402               		.loc 3 173 2 view .LVU90
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 403               		.loc 3 174 2 view .LVU91
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 404               		.loc 3 184 3 view .LVU92
 405               		.loc 3 187 2 view .LVU93
 406 0054 2FEF      		ldi r18,lo8(319999)
 407 0056 81EE      		ldi r24,hi8(319999)
 408 0058 94E0      		ldi r25,hlo8(319999)
 409 005a 2150      	1:	subi r18,1
 410 005c 8040      		sbci r24,0
 411 005e 9040      		sbci r25,0
 412 0060 01F4      		brne 1b
 413 0062 00C0      		rjmp .
 414 0064 0000      		nop
 415               	.LVL28:
 416               		.loc 3 187 2 is_stmt 0 view .LVU94
 417               	.LBE21:
 418               	.LBE20:
 726:tmk_core/common/action.c ****         send_keyboard_report();
 419               		.loc 1 726 9 is_stmt 1 view .LVU95
 420 0066 83E5      		ldi r24,lo8(83)
 421 0068 00C0      		rjmp .L61
 422               	.LVL29:
 423               	.L28:
 730:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 424               		.loc 1 730 10 view .LVU96
 730:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 425               		.loc 1 730 13 is_stmt 0 view .LVU97
 426 006a 8438      		cpi r24,lo8(-124)
 427 006c 01F4      		brne .L29
 732:tmk_core/common/action.c **** #endif
 428               		.loc 1 732 9 is_stmt 1 view .LVU98
 732:tmk_core/common/action.c **** #endif
 429               		.loc 1 732 13 is_stmt 0 view .LVU99
 430 006e 0E94 0000 		call host_keyboard_leds
 431               	.LVL30:
 732:tmk_core/common/action.c **** #endif
 432               		.loc 1 732 12 view .LVU100
 433 0072 82FD      		sbrc r24,2
 434 0074 00C0      		rjmp .L23
 734:tmk_core/common/action.c ****         send_keyboard_report();
 435               		.loc 1 734 9 is_stmt 1 view .LVU101
 436 0076 87E4      		ldi r24,lo8(71)
 437 0078 0E94 0000 		call add_key
 438               	.LVL31:
 735:tmk_core/common/action.c ****         wait_ms(100);
 439               		.loc 1 735 9 view .LVU102
 440 007c 0E94 0000 		call send_keyboard_report
 441               	.LVL32:
 736:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 442               		.loc 1 736 9 view .LVU103
 443               	.LBB22:
 444               	.LBI22:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 445               		.loc 3 166 1 view .LVU104
 446               	.LBB23:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 447               		.loc 3 168 2 view .LVU105
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 448               		.loc 3 172 2 view .LVU106
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 449               		.loc 3 173 2 view .LVU107
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 450               		.loc 3 174 2 view .LVU108
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 451               		.loc 3 184 3 view .LVU109
 452               		.loc 3 187 2 view .LVU110
 453 0080 2FEF      		ldi r18,lo8(319999)
 454 0082 81EE      		ldi r24,hi8(319999)
 455 0084 94E0      		ldi r25,hlo8(319999)
 456 0086 2150      	1:	subi r18,1
 457 0088 8040      		sbci r24,0
 458 008a 9040      		sbci r25,0
 459 008c 01F4      		brne 1b
 460 008e 00C0      		rjmp .
 461 0090 0000      		nop
 462               	.LVL33:
 463               		.loc 3 187 2 is_stmt 0 view .LVU111
 464               	.LBE23:
 465               	.LBE22:
 737:tmk_core/common/action.c ****         send_keyboard_report();
 466               		.loc 1 737 9 is_stmt 1 view .LVU112
 467 0092 87E4      		ldi r24,lo8(71)
 468 0094 00C0      		rjmp .L61
 469               	.LVL34:
 470               	.L29:
 742:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 471               		.loc 1 742 10 view .LVU113
 742:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 472               		.loc 1 742 13 is_stmt 0 view .LVU114
 473 0096 8CEF      		ldi r24,lo8(-4)
 474               	.LVL35:
 742:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 475               		.loc 1 742 13 view .LVU115
 476 0098 8C0F      		add r24,r28
 477 009a 813A      		cpi r24,lo8(-95)
 478 009c 00F4      		brsh .L30
 744:tmk_core/common/action.c **** 
 479               		.loc 1 744 9 is_stmt 1 view .LVU116
 744:tmk_core/common/action.c **** 
 480               		.loc 1 744 13 is_stmt 0 view .LVU117
 481 009e 8C2F      		mov r24,r28
 482 00a0 0E94 0000 		call command_proc
 483               	.LVL36:
 744:tmk_core/common/action.c **** 
 484               		.loc 1 744 12 view .LVU118
 485 00a4 8111      		cpse r24,__zero_reg__
 486 00a6 00C0      		rjmp .L23
 762:tmk_core/common/action.c ****             send_keyboard_report();
 487               		.loc 1 762 13 is_stmt 1 view .LVU119
 488 00a8 8C2F      		mov r24,r28
 489 00aa 0E94 0000 		call add_key
 490               	.LVL37:
 763:tmk_core/common/action.c ****         }
 491               		.loc 1 763 13 view .LVU120
 492 00ae 00C0      		rjmp .L62
 493               	.L30:
 766:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 494               		.loc 1 766 10 view .LVU121
 766:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 495               		.loc 1 766 13 is_stmt 0 view .LVU122
 496 00b0 80E2      		ldi r24,lo8(32)
 497 00b2 8C0F      		add r24,r28
 498 00b4 8830      		cpi r24,lo8(8)
 499 00b6 00F4      		brsh .L31
 767:tmk_core/common/action.c ****         send_keyboard_report();
 500               		.loc 1 767 9 is_stmt 1 view .LVU123
 767:tmk_core/common/action.c ****         send_keyboard_report();
 501               		.loc 1 767 18 is_stmt 0 view .LVU124
 502 00b8 C770      		andi r28,lo8(7)
 503               	.LVL38:
 767:tmk_core/common/action.c ****         send_keyboard_report();
 504               		.loc 1 767 9 view .LVU125
 505 00ba 81E0      		ldi r24,lo8(1)
 506 00bc 00C0      		rjmp 2f
 507               		1:
 508 00be 880F      		lsl r24
 509               		2:
 510 00c0 CA95      		dec r28
 511 00c2 02F4      		brpl 1b
 512 00c4 0E94 0000 		call add_mods
 513               	.LVL39:
 768:tmk_core/common/action.c ****     }
 514               		.loc 1 768 9 is_stmt 1 view .LVU126
 515 00c8 00C0      		rjmp .L62
 516               	.LVL40:
 517               	.L31:
 770:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 518               		.loc 1 770 10 view .LVU127
 770:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 519               		.loc 1 770 13 is_stmt 0 view .LVU128
 520 00ca 8BE5      		ldi r24,lo8(91)
 521 00cc 8C0F      		add r24,r28
 522 00ce 8330      		cpi r24,lo8(3)
 523 00d0 00F4      		brsh .L32
 771:tmk_core/common/action.c ****     }
 524               		.loc 1 771 9 is_stmt 1 view .LVU129
 525 00d2 81E8      		ldi r24,lo8(-127)
 526 00d4 90E0      		ldi r25,0
 527 00d6 C53A      		cpi r28,lo8(-91)
 528 00d8 01F0      		breq .L33
 771:tmk_core/common/action.c ****     }
 529               		.loc 1 771 26 is_stmt 0 discriminator 1 view .LVU130
 530 00da 83E8      		ldi r24,lo8(-125)
 531 00dc 90E0      		ldi r25,0
 532 00de C63A      		cpi r28,lo8(-90)
 533 00e0 01F4      		brne .L33
 771:tmk_core/common/action.c ****     }
 534               		.loc 1 771 26 view .LVU131
 535 00e2 82E8      		ldi r24,lo8(-126)
 536 00e4 90E0      		ldi r25,0
 537               	.L33:
 538               	/* epilogue start */
 539               		.loc 1 783 1 discriminator 12 view .LVU132
 540 00e6 CF91      		pop r28
 541               	.LVL41:
 771:tmk_core/common/action.c ****     }
 542               		.loc 1 771 9 discriminator 12 view .LVU133
 543 00e8 0C94 0000 		jmp host_system_send
 544               	.LVL42:
 545               	.L32:
 773:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 546               		.loc 1 773 10 is_stmt 1 view .LVU134
 773:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 547               		.loc 1 773 13 is_stmt 0 view .LVU135
 548 00ec 88E5      		ldi r24,lo8(88)
 549 00ee 8C0F      		add r24,r28
 550 00f0 8731      		cpi r24,lo8(23)
 551 00f2 00F0      		brlo .+2
 552 00f4 00C0      		rjmp .L34
 774:tmk_core/common/action.c ****     }
 553               		.loc 1 774 9 is_stmt 1 view .LVU136
 554 00f6 82EE      		ldi r24,lo8(-30)
 555 00f8 90E0      		ldi r25,0
 556 00fa C83A      		cpi r28,lo8(-88)
 557 00fc 01F4      		brne .+2
 558 00fe 00C0      		rjmp .L35
 774:tmk_core/common/action.c ****     }
 559               		.loc 1 774 28 is_stmt 0 discriminator 1 view .LVU137
 560 0100 89EE      		ldi r24,lo8(-23)
 561 0102 90E0      		ldi r25,0
 562 0104 C93A      		cpi r28,lo8(-87)
 563 0106 01F4      		brne .+2
 564 0108 00C0      		rjmp .L35
 774:tmk_core/common/action.c ****     }
 565               		.loc 1 774 28 discriminator 3 view .LVU138
 566 010a 8AEE      		ldi r24,lo8(-22)
 567 010c 90E0      		ldi r25,0
 568 010e CA3A      		cpi r28,lo8(-86)
 569 0110 01F4      		brne .+2
 570 0112 00C0      		rjmp .L35
 774:tmk_core/common/action.c ****     }
 571               		.loc 1 774 28 discriminator 5 view .LVU139
 572 0114 85EB      		ldi r24,lo8(-75)
 573 0116 90E0      		ldi r25,0
 574 0118 CB3A      		cpi r28,lo8(-85)
 575 011a 01F4      		brne .+2
 576 011c 00C0      		rjmp .L35
 774:tmk_core/common/action.c ****     }
 577               		.loc 1 774 28 discriminator 7 view .LVU140
 578 011e 86EB      		ldi r24,lo8(-74)
 579 0120 90E0      		ldi r25,0
 580 0122 CC3A      		cpi r28,lo8(-84)
 581 0124 01F4      		brne .+2
 582 0126 00C0      		rjmp .L35
 774:tmk_core/common/action.c ****     }
 583               		.loc 1 774 28 discriminator 9 view .LVU141
 584 0128 83EB      		ldi r24,lo8(-77)
 585 012a 90E0      		ldi r25,0
 586 012c CB3B      		cpi r28,lo8(-69)
 587 012e 01F4      		brne .+2
 588 0130 00C0      		rjmp .L35
 774:tmk_core/common/action.c ****     }
 589               		.loc 1 774 28 discriminator 11 view .LVU142
 590 0132 84EB      		ldi r24,lo8(-76)
 591 0134 90E0      		ldi r25,0
 592 0136 CC3B      		cpi r28,lo8(-68)
 593 0138 01F4      		brne .+2
 594 013a 00C0      		rjmp .L35
 774:tmk_core/common/action.c ****     }
 595               		.loc 1 774 28 discriminator 13 view .LVU143
 596 013c 87EB      		ldi r24,lo8(-73)
 597 013e 90E0      		ldi r25,0
 598 0140 CD3A      		cpi r28,lo8(-83)
 599 0142 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 600               		.loc 1 774 28 discriminator 15 view .LVU144
 601 0144 8CEC      		ldi r24,lo8(-52)
 602 0146 90E0      		ldi r25,0
 603 0148 C03B      		cpi r28,lo8(-80)
 604 014a 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 605               		.loc 1 774 28 discriminator 17 view .LVU145
 606 014c 8DEC      		ldi r24,lo8(-51)
 607 014e 90E0      		ldi r25,0
 608 0150 CE3A      		cpi r28,lo8(-82)
 609 0152 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 610               		.loc 1 774 28 discriminator 19 view .LVU146
 611 0154 83E8      		ldi r24,lo8(-125)
 612 0156 91E0      		ldi r25,lo8(1)
 613 0158 CF3A      		cpi r28,lo8(-81)
 614 015a 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 615               		.loc 1 774 28 discriminator 21 view .LVU147
 616 015c 8AE8      		ldi r24,lo8(-118)
 617 015e 91E0      		ldi r25,lo8(1)
 618 0160 C13B      		cpi r28,lo8(-79)
 619 0162 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 620               		.loc 1 774 28 discriminator 23 view .LVU148
 621 0164 82E9      		ldi r24,lo8(-110)
 622 0166 91E0      		ldi r25,lo8(1)
 623 0168 C23B      		cpi r28,lo8(-78)
 624 016a 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 625               		.loc 1 774 28 discriminator 25 view .LVU149
 626 016c 84E9      		ldi r24,lo8(-108)
 627 016e 91E0      		ldi r25,lo8(1)
 628 0170 C33B      		cpi r28,lo8(-77)
 629 0172 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 630               		.loc 1 774 28 discriminator 27 view .LVU150
 631 0174 81E2      		ldi r24,lo8(33)
 632 0176 92E0      		ldi r25,lo8(2)
 633 0178 C43B      		cpi r28,lo8(-76)
 634 017a 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 635               		.loc 1 774 28 discriminator 29 view .LVU151
 636 017c 83E2      		ldi r24,lo8(35)
 637 017e 92E0      		ldi r25,lo8(2)
 638 0180 C53B      		cpi r28,lo8(-75)
 639 0182 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 640               		.loc 1 774 28 discriminator 31 view .LVU152
 641 0184 84E2      		ldi r24,lo8(36)
 642 0186 92E0      		ldi r25,lo8(2)
 643 0188 C63B      		cpi r28,lo8(-74)
 644 018a 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 645               		.loc 1 774 28 discriminator 33 view .LVU153
 646 018c 85E2      		ldi r24,lo8(37)
 647 018e 92E0      		ldi r25,lo8(2)
 648 0190 C73B      		cpi r28,lo8(-73)
 649 0192 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 650               		.loc 1 774 28 discriminator 35 view .LVU154
 651 0194 86E2      		ldi r24,lo8(38)
 652 0196 92E0      		ldi r25,lo8(2)
 653 0198 C83B      		cpi r28,lo8(-72)
 654 019a 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 655               		.loc 1 774 28 discriminator 37 view .LVU155
 656 019c 87E2      		ldi r24,lo8(39)
 657 019e 92E0      		ldi r25,lo8(2)
 658 01a0 C93B      		cpi r28,lo8(-71)
 659 01a2 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 660               		.loc 1 774 28 discriminator 39 view .LVU156
 661 01a4 8FE6      		ldi r24,lo8(111)
 662 01a6 90E0      		ldi r25,0
 663 01a8 CD3B      		cpi r28,lo8(-67)
 664 01aa 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 665               		.loc 1 774 28 discriminator 41 view .LVU157
 666 01ac 80E7      		ldi r24,lo8(112)
 667 01ae 90E0      		ldi r25,0
 668 01b0 CE3B      		cpi r28,lo8(-66)
 669 01b2 01F0      		breq .L35
 774:tmk_core/common/action.c ****     }
 670               		.loc 1 774 28 discriminator 43 view .LVU158
 671 01b4 90E0      		ldi r25,0
 672 01b6 80E0      		ldi r24,0
 673 01b8 CA3B      		cpi r28,lo8(-70)
 674 01ba 01F4      		brne .L35
 774:tmk_core/common/action.c ****     }
 675               		.loc 1 774 28 view .LVU159
 676 01bc 8AE2      		ldi r24,lo8(42)
 677 01be 92E0      		ldi r25,lo8(2)
 678               	.L35:
 679               	/* epilogue start */
 680               		.loc 1 783 1 discriminator 92 view .LVU160
 681 01c0 CF91      		pop r28
 682               	.LVL43:
 774:tmk_core/common/action.c ****     }
 683               		.loc 1 774 9 discriminator 92 view .LVU161
 684 01c2 0C94 0000 		jmp host_consumer_send
 685               	.LVL44:
 686               	.L34:
 778:tmk_core/common/action.c ****         mousekey_on(code);
 687               		.loc 1 778 12 is_stmt 1 view .LVU162
 778:tmk_core/common/action.c ****         mousekey_on(code);
 688               		.loc 1 778 15 is_stmt 0 view .LVU163
 689 01c6 C03F      		cpi r28,lo8(-16)
 690 01c8 00F0      		brlo .L23
 779:tmk_core/common/action.c ****         mousekey_send();
 691               		.loc 1 779 9 is_stmt 1 view .LVU164
 692 01ca 8C2F      		mov r24,r28
 693 01cc 0E94 0000 		call mousekey_on
 694               	.LVL45:
 780:tmk_core/common/action.c ****       }
 695               		.loc 1 780 9 view .LVU165
 696               	/* epilogue start */
 697               		.loc 1 783 1 is_stmt 0 view .LVU166
 698 01d0 CF91      		pop r28
 699               	.LVL46:
 780:tmk_core/common/action.c ****       }
 700               		.loc 1 780 9 view .LVU167
 701 01d2 0C94 0000 		jmp mousekey_send
 702               	.LVL47:
 703               	.L23:
 704               	/* epilogue start */
 705               		.loc 1 783 1 view .LVU168
 706 01d6 CF91      		pop r28
 707               	.LVL48:
 708               		.loc 1 783 1 view .LVU169
 709 01d8 0895      		ret
 710               		.cfi_endproc
 711               	.LFE113:
 713               		.section	.text.unregister_code,"ax",@progbits
 714               	.global	unregister_code
 716               	unregister_code:
 717               	.LVL49:
 718               	.LFB114:
 784:tmk_core/common/action.c **** 
 785:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 786:tmk_core/common/action.c ****  *
 787:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 788:tmk_core/common/action.c ****  */
 789:tmk_core/common/action.c **** void unregister_code(uint8_t code)
 790:tmk_core/common/action.c **** {
 719               		.loc 1 790 1 is_stmt 1 view -0
 720               		.cfi_startproc
 721               	/* prologue: function */
 722               	/* frame size = 0 */
 723               	/* stack size = 0 */
 724               	.L__stack_usage = 0
 791:tmk_core/common/action.c ****     if (code == KC_NO) {
 725               		.loc 1 791 5 view .LVU171
 726               		.loc 1 791 8 is_stmt 0 view .LVU172
 727 0000 8823      		tst r24
 728 0002 01F4      		brne .+2
 729 0004 00C0      		rjmp .L63
 792:tmk_core/common/action.c ****         return;
 793:tmk_core/common/action.c ****     }
 794:tmk_core/common/action.c **** 
 795:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 796:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 730               		.loc 1 796 10 is_stmt 1 view .LVU173
 731               		.loc 1 796 13 is_stmt 0 view .LVU174
 732 0006 8238      		cpi r24,lo8(-126)
 733 0008 01F4      		brne .L66
 797:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 798:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 799:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 734               		.loc 1 799 9 is_stmt 1 view .LVU175
 735               		.loc 1 799 15 is_stmt 0 view .LVU176
 736 000a 0E94 0000 		call host_keyboard_leds
 737               	.LVL50:
 738               		.loc 1 799 12 view .LVU177
 739 000e 81FF      		sbrs r24,1
 740 0010 00C0      		rjmp .L63
 800:tmk_core/common/action.c **** #endif
 801:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 741               		.loc 1 801 9 is_stmt 1 view .LVU178
 742 0012 89E3      		ldi r24,lo8(57)
 743 0014 0E94 0000 		call add_key
 744               	.LVL51:
 802:tmk_core/common/action.c ****         send_keyboard_report();
 745               		.loc 1 802 9 view .LVU179
 746 0018 0E94 0000 		call send_keyboard_report
 747               	.LVL52:
 803:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 748               		.loc 1 803 9 view .LVU180
 749 001c 89E3      		ldi r24,lo8(57)
 750               	.L83:
 804:tmk_core/common/action.c ****         send_keyboard_report();
 805:tmk_core/common/action.c ****     }
 806:tmk_core/common/action.c **** 
 807:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 808:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 809:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 810:tmk_core/common/action.c **** #endif
 811:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 812:tmk_core/common/action.c ****         send_keyboard_report();
 813:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 751               		.loc 1 813 9 is_stmt 0 view .LVU181
 752 001e 0E94 0000 		call del_key
 753               	.LVL53:
 754               	.L84:
 814:tmk_core/common/action.c ****         send_keyboard_report();
 755               		.loc 1 814 9 is_stmt 1 view .LVU182
 756 0022 0C94 0000 		jmp send_keyboard_report
 757               	.LVL54:
 758               	.L66:
 807:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 759               		.loc 1 807 10 view .LVU183
 807:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 760               		.loc 1 807 13 is_stmt 0 view .LVU184
 761 0026 8338      		cpi r24,lo8(-125)
 762 0028 01F4      		brne .L68
 809:tmk_core/common/action.c **** #endif
 763               		.loc 1 809 9 is_stmt 1 view .LVU185
 809:tmk_core/common/action.c **** #endif
 764               		.loc 1 809 15 is_stmt 0 view .LVU186
 765 002a 0E94 0000 		call host_keyboard_leds
 766               	.LVL55:
 809:tmk_core/common/action.c **** #endif
 767               		.loc 1 809 12 view .LVU187
 768 002e 80FF      		sbrs r24,0
 769 0030 00C0      		rjmp .L63
 811:tmk_core/common/action.c ****         send_keyboard_report();
 770               		.loc 1 811 9 is_stmt 1 view .LVU188
 771 0032 83E5      		ldi r24,lo8(83)
 772 0034 0E94 0000 		call add_key
 773               	.LVL56:
 812:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 774               		.loc 1 812 9 view .LVU189
 775 0038 0E94 0000 		call send_keyboard_report
 776               	.LVL57:
 813:tmk_core/common/action.c ****         send_keyboard_report();
 777               		.loc 1 813 9 view .LVU190
 778 003c 83E5      		ldi r24,lo8(83)
 779 003e 00C0      		rjmp .L83
 780               	.LVL58:
 781               	.L68:
 815:tmk_core/common/action.c ****     }
 816:tmk_core/common/action.c **** 
 817:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 782               		.loc 1 817 10 view .LVU191
 783               		.loc 1 817 13 is_stmt 0 view .LVU192
 784 0040 8438      		cpi r24,lo8(-124)
 785 0042 01F4      		brne .L69
 818:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 819:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 786               		.loc 1 819 9 is_stmt 1 view .LVU193
 787               		.loc 1 819 15 is_stmt 0 view .LVU194
 788 0044 0E94 0000 		call host_keyboard_leds
 789               	.LVL59:
 790               		.loc 1 819 12 view .LVU195
 791 0048 82FF      		sbrs r24,2
 792 004a 00C0      		rjmp .L63
 820:tmk_core/common/action.c **** #endif
 821:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 793               		.loc 1 821 9 is_stmt 1 view .LVU196
 794 004c 87E4      		ldi r24,lo8(71)
 795 004e 0E94 0000 		call add_key
 796               	.LVL60:
 822:tmk_core/common/action.c ****         send_keyboard_report();
 797               		.loc 1 822 9 view .LVU197
 798 0052 0E94 0000 		call send_keyboard_report
 799               	.LVL61:
 823:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 800               		.loc 1 823 9 view .LVU198
 801 0056 87E4      		ldi r24,lo8(71)
 802 0058 00C0      		rjmp .L83
 803               	.LVL62:
 804               	.L69:
 824:tmk_core/common/action.c ****         send_keyboard_report();
 825:tmk_core/common/action.c ****     }
 826:tmk_core/common/action.c **** #endif
 827:tmk_core/common/action.c **** 
 828:tmk_core/common/action.c ****     else if IS_KEY(code) {
 805               		.loc 1 828 10 view .LVU199
 806               		.loc 1 828 13 is_stmt 0 view .LVU200
 807 005a 9CEF      		ldi r25,lo8(-4)
 808 005c 980F      		add r25,r24
 809 005e 913A      		cpi r25,lo8(-95)
 810 0060 00F0      		brlo .L83
 829:tmk_core/common/action.c ****         del_key(code);
 830:tmk_core/common/action.c ****         send_keyboard_report();
 831:tmk_core/common/action.c ****     }
 832:tmk_core/common/action.c ****     else if IS_MOD(code) {
 811               		.loc 1 832 10 is_stmt 1 view .LVU201
 812               		.loc 1 832 13 is_stmt 0 view .LVU202
 813 0062 90E2      		ldi r25,lo8(32)
 814 0064 980F      		add r25,r24
 815 0066 9830      		cpi r25,lo8(8)
 816 0068 00F4      		brsh .L71
 833:tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 817               		.loc 1 833 9 is_stmt 1 view .LVU203
 818               		.loc 1 833 18 is_stmt 0 view .LVU204
 819 006a 8770      		andi r24,lo8(7)
 820               	.LVL63:
 821               		.loc 1 833 9 view .LVU205
 822 006c 91E0      		ldi r25,lo8(1)
 823 006e 00C0      		rjmp 2f
 824               		1:
 825 0070 990F      		lsl r25
 826               		2:
 827 0072 8A95      		dec r24
 828 0074 02F4      		brpl 1b
 829 0076 892F      		mov r24,r25
 830 0078 0E94 0000 		call del_mods
 831               	.LVL64:
 834:tmk_core/common/action.c ****         send_keyboard_report();
 832               		.loc 1 834 9 is_stmt 1 view .LVU206
 833 007c 00C0      		rjmp .L84
 834               	.LVL65:
 835               	.L71:
 835:tmk_core/common/action.c ****     }
 836:tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 836               		.loc 1 836 10 view .LVU207
 837               		.loc 1 836 13 is_stmt 0 view .LVU208
 838 007e 9BE5      		ldi r25,lo8(91)
 839 0080 980F      		add r25,r24
 840 0082 9330      		cpi r25,lo8(3)
 841 0084 00F4      		brsh .L72
 837:tmk_core/common/action.c ****         host_system_send(0);
 842               		.loc 1 837 9 is_stmt 1 view .LVU209
 843 0086 90E0      		ldi r25,0
 844 0088 80E0      		ldi r24,0
 845               	.LVL66:
 846               		.loc 1 837 9 is_stmt 0 view .LVU210
 847 008a 0C94 0000 		jmp host_system_send
 848               	.LVL67:
 849               	.L72:
 838:tmk_core/common/action.c ****     }
 839:tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 850               		.loc 1 839 10 is_stmt 1 view .LVU211
 851               		.loc 1 839 13 is_stmt 0 view .LVU212
 852 008e 98E5      		ldi r25,lo8(88)
 853 0090 980F      		add r25,r24
 854 0092 9731      		cpi r25,lo8(23)
 855 0094 00F4      		brsh .L73
 840:tmk_core/common/action.c ****         host_consumer_send(0);
 856               		.loc 1 840 9 is_stmt 1 view .LVU213
 857 0096 90E0      		ldi r25,0
 858 0098 80E0      		ldi r24,0
 859               	.LVL68:
 860               		.loc 1 840 9 is_stmt 0 view .LVU214
 861 009a 0C94 0000 		jmp host_consumer_send
 862               	.LVL69:
 863               	.L73:
 841:tmk_core/common/action.c ****     }
 842:tmk_core/common/action.c ****     #ifdef MOUSEKEY_ENABLE
 843:tmk_core/common/action.c ****       else if IS_MOUSEKEY(code) {
 864               		.loc 1 843 12 is_stmt 1 view .LVU215
 865               		.loc 1 843 15 is_stmt 0 view .LVU216
 866 009e 803F      		cpi r24,lo8(-16)
 867 00a0 00F0      		brlo .L63
 844:tmk_core/common/action.c ****         mousekey_off(code);
 868               		.loc 1 844 9 is_stmt 1 view .LVU217
 869 00a2 0E94 0000 		call mousekey_off
 870               	.LVL70:
 845:tmk_core/common/action.c ****         mousekey_send();
 871               		.loc 1 845 9 view .LVU218
 872 00a6 0C94 0000 		jmp mousekey_send
 873               	.LVL71:
 874               	.L63:
 875               	/* epilogue start */
 846:tmk_core/common/action.c ****       }
 847:tmk_core/common/action.c ****     #endif
 848:tmk_core/common/action.c **** }
 876               		.loc 1 848 1 is_stmt 0 view .LVU219
 877 00aa 0895      		ret
 878               		.cfi_endproc
 879               	.LFE114:
 881               		.section	.text.tap_code,"ax",@progbits
 882               	.global	tap_code
 884               	tap_code:
 885               	.LVL72:
 886               	.LFB115:
 849:tmk_core/common/action.c **** 
 850:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 851:tmk_core/common/action.c ****  *
 852:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 853:tmk_core/common/action.c ****  */
 854:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 887               		.loc 1 854 29 is_stmt 1 view -0
 888               		.cfi_startproc
 889               		.loc 1 854 29 is_stmt 0 view .LVU221
 890 0000 CF93      		push r28
 891               	.LCFI7:
 892               		.cfi_def_cfa_offset 3
 893               		.cfi_offset 28, -2
 894               	/* prologue: function */
 895               	/* frame size = 0 */
 896               	/* stack size = 1 */
 897               	.L__stack_usage = 1
 898 0002 C82F      		mov r28,r24
 855:tmk_core/common/action.c ****   register_code(code);
 899               		.loc 1 855 3 is_stmt 1 view .LVU222
 900 0004 0E94 0000 		call register_code
 901               	.LVL73:
 856:tmk_core/common/action.c ****   #if TAP_CODE_DELAY > 0
 857:tmk_core/common/action.c ****     wait_ms(TAP_CODE_DELAY);
 858:tmk_core/common/action.c ****   #endif
 859:tmk_core/common/action.c ****   unregister_code(code);
 902               		.loc 1 859 3 view .LVU223
 903 0008 8C2F      		mov r24,r28
 904               	/* epilogue start */
 860:tmk_core/common/action.c **** }
 905               		.loc 1 860 1 is_stmt 0 view .LVU224
 906 000a CF91      		pop r28
 907               	.LVL74:
 859:tmk_core/common/action.c **** }
 908               		.loc 1 859 3 view .LVU225
 909 000c 0C94 0000 		jmp unregister_code
 910               	.LVL75:
 859:tmk_core/common/action.c **** }
 911               		.loc 1 859 3 view .LVU226
 912               		.cfi_endproc
 913               	.LFE115:
 915               		.section	.text.register_mods,"ax",@progbits
 916               	.global	register_mods
 918               	register_mods:
 919               	.LVL76:
 920               	.LFB116:
 861:tmk_core/common/action.c **** 
 862:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 863:tmk_core/common/action.c ****  *
 864:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 865:tmk_core/common/action.c ****  */
 866:tmk_core/common/action.c **** void register_mods(uint8_t mods)
 867:tmk_core/common/action.c **** {
 921               		.loc 1 867 1 is_stmt 1 view -0
 922               		.cfi_startproc
 923               	/* prologue: function */
 924               	/* frame size = 0 */
 925               	/* stack size = 0 */
 926               	.L__stack_usage = 0
 868:tmk_core/common/action.c ****     if (mods) {
 927               		.loc 1 868 5 view .LVU228
 928               		.loc 1 868 8 is_stmt 0 view .LVU229
 929 0000 8823      		tst r24
 930 0002 01F0      		breq .L86
 869:tmk_core/common/action.c ****         add_mods(mods);
 931               		.loc 1 869 9 is_stmt 1 view .LVU230
 932 0004 0E94 0000 		call add_mods
 933               	.LVL77:
 870:tmk_core/common/action.c ****         send_keyboard_report();
 934               		.loc 1 870 9 view .LVU231
 935 0008 0C94 0000 		jmp send_keyboard_report
 936               	.LVL78:
 937               	.L86:
 938               	/* epilogue start */
 871:tmk_core/common/action.c ****     }
 872:tmk_core/common/action.c **** }
 939               		.loc 1 872 1 is_stmt 0 view .LVU232
 940 000c 0895      		ret
 941               		.cfi_endproc
 942               	.LFE116:
 944               		.section	.text.unregister_mods,"ax",@progbits
 945               	.global	unregister_mods
 947               	unregister_mods:
 948               	.LVL79:
 949               	.LFB117:
 873:tmk_core/common/action.c **** 
 874:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 875:tmk_core/common/action.c ****  *
 876:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 877:tmk_core/common/action.c ****  */
 878:tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 879:tmk_core/common/action.c **** {
 950               		.loc 1 879 1 is_stmt 1 view -0
 951               		.cfi_startproc
 952               	/* prologue: function */
 953               	/* frame size = 0 */
 954               	/* stack size = 0 */
 955               	.L__stack_usage = 0
 880:tmk_core/common/action.c ****     if (mods) {
 956               		.loc 1 880 5 view .LVU234
 957               		.loc 1 880 8 is_stmt 0 view .LVU235
 958 0000 8823      		tst r24
 959 0002 01F0      		breq .L88
 881:tmk_core/common/action.c ****         del_mods(mods);
 960               		.loc 1 881 9 is_stmt 1 view .LVU236
 961 0004 0E94 0000 		call del_mods
 962               	.LVL80:
 882:tmk_core/common/action.c ****         send_keyboard_report();
 963               		.loc 1 882 9 view .LVU237
 964 0008 0C94 0000 		jmp send_keyboard_report
 965               	.LVL81:
 966               	.L88:
 967               	/* epilogue start */
 883:tmk_core/common/action.c ****     }
 884:tmk_core/common/action.c **** }
 968               		.loc 1 884 1 is_stmt 0 view .LVU238
 969 000c 0895      		ret
 970               		.cfi_endproc
 971               	.LFE117:
 973               		.section	.text.process_action,"ax",@progbits
 974               	.global	process_action
 976               	process_action:
 977               	.LVL82:
 978               	.LFB112:
 195:tmk_core/common/action.c ****     keyevent_t event = record->event;
 979               		.loc 1 195 1 is_stmt 1 view -0
 980               		.cfi_startproc
 195:tmk_core/common/action.c ****     keyevent_t event = record->event;
 981               		.loc 1 195 1 is_stmt 0 view .LVU240
 982 0000 8F92      		push r8
 983               	.LCFI8:
 984               		.cfi_def_cfa_offset 3
 985               		.cfi_offset 8, -2
 986 0002 9F92      		push r9
 987               	.LCFI9:
 988               		.cfi_def_cfa_offset 4
 989               		.cfi_offset 9, -3
 990 0004 AF92      		push r10
 991               	.LCFI10:
 992               		.cfi_def_cfa_offset 5
 993               		.cfi_offset 10, -4
 994 0006 BF92      		push r11
 995               	.LCFI11:
 996               		.cfi_def_cfa_offset 6
 997               		.cfi_offset 11, -5
 998 0008 CF92      		push r12
 999               	.LCFI12:
 1000               		.cfi_def_cfa_offset 7
 1001               		.cfi_offset 12, -6
 1002 000a DF92      		push r13
 1003               	.LCFI13:
 1004               		.cfi_def_cfa_offset 8
 1005               		.cfi_offset 13, -7
 1006 000c EF92      		push r14
 1007               	.LCFI14:
 1008               		.cfi_def_cfa_offset 9
 1009               		.cfi_offset 14, -8
 1010 000e FF92      		push r15
 1011               	.LCFI15:
 1012               		.cfi_def_cfa_offset 10
 1013               		.cfi_offset 15, -9
 1014 0010 0F93      		push r16
 1015               	.LCFI16:
 1016               		.cfi_def_cfa_offset 11
 1017               		.cfi_offset 16, -10
 1018 0012 1F93      		push r17
 1019               	.LCFI17:
 1020               		.cfi_def_cfa_offset 12
 1021               		.cfi_offset 17, -11
 1022 0014 CF93      		push r28
 1023               	.LCFI18:
 1024               		.cfi_def_cfa_offset 13
 1025               		.cfi_offset 28, -12
 1026 0016 DF93      		push r29
 1027               	.LCFI19:
 1028               		.cfi_def_cfa_offset 14
 1029               		.cfi_offset 29, -13
 1030               	/* prologue: function */
 1031               	/* frame size = 0 */
 1032               	/* stack size = 12 */
 1033               	.L__stack_usage = 12
 1034 0018 7C01      		movw r14,r24
 1035 001a D62F      		mov r29,r22
 195:tmk_core/common/action.c ****     keyevent_t event = record->event;
 1036               		.loc 1 195 1 view .LVU241
 1037 001c C72F      		mov r28,r23
 196:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 1038               		.loc 1 196 5 is_stmt 1 view .LVU242
 1039               	.LVL83:
 198:tmk_core/common/action.c **** #endif
 1040               		.loc 1 198 5 view .LVU243
 198:tmk_core/common/action.c **** #endif
 1041               		.loc 1 198 36 is_stmt 0 view .LVU244
 1042 001e FC01      		movw r30,r24
 1043 0020 0581      		ldd r16,Z+5
 1044 0022 0295      		swap r16
 1045 0024 0F70      		andi r16,lo8(15)
 1046               	.LVL84:
 201:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 1047               		.loc 1 201 5 is_stmt 1 view .LVU245
 201:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 1048               		.loc 1 201 14 is_stmt 0 view .LVU246
 1049 0026 1281      		ldd r17,Z+2
 201:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 1050               		.loc 1 201 8 view .LVU247
 1051 0028 1111      		cpse r17,__zero_reg__
 203:tmk_core/common/action.c ****     }
 1052               		.loc 1 203 9 is_stmt 1 view .LVU248
 1053 002a 0E94 0000 		call clear_weak_mods
 1054               	.LVL85:
 1055               	.L91:
 207:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 1056               		.loc 1 207 5 view .LVU249
 209:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1057               		.loc 1 209 5 view .LVU250
 209:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1058               		.loc 1 209 9 is_stmt 0 view .LVU251
 1059 002e 0E94 0000 		call is_oneshot_layer_active
 1060               	.LVL86:
 209:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1061               		.loc 1 209 9 view .LVU252
 1062 0032 C82E      		mov r12,r24
 209:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1063               		.loc 1 209 8 view .LVU253
 1064 0034 8823      		tst r24
 1065 0036 01F0      		breq .L92
 209:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1066               		.loc 1 209 35 discriminator 1 view .LVU254
 1067 0038 1123      		tst r17
 1068 003a 01F0      		breq .L187
 209:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1069               		.loc 1 209 55 discriminator 2 view .LVU255
 1070 003c 80E2      		ldi r24,lo8(32)
 209:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1071               		.loc 1 209 55 discriminator 2 view .LVU256
 1072 003e 8D0F      		add r24,r29
 209:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1073               		.loc 1 209 52 discriminator 2 view .LVU257
 1074 0040 8830      		cpi r24,lo8(8)
 1075 0042 00F0      		brlo .L187
 210:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 1076               		.loc 1 210 9 is_stmt 1 view .LVU258
 1077 0044 82E0      		ldi r24,lo8(2)
 1078 0046 0E94 0000 		call clear_oneshot_layer_state
 1079               	.LVL87:
 211:tmk_core/common/action.c ****     }
 1080               		.loc 1 211 9 view .LVU259
 211:tmk_core/common/action.c ****     }
 1081               		.loc 1 211 31 is_stmt 0 view .LVU260
 1082 004a 0E94 0000 		call is_oneshot_layer_active
 1083               	.LVL88:
 211:tmk_core/common/action.c ****     }
 1084               		.loc 1 211 9 view .LVU261
 1085 004e 91E0      		ldi r25,lo8(1)
 1086 0050 C82E      		mov r12,r24
 1087 0052 C926      		eor r12,r25
 1088               	.LVL89:
 1089               	.L92:
 215:tmk_core/common/action.c ****         /* Key and Mods */
 1090               		.loc 1 215 5 is_stmt 1 view .LVU262
 215:tmk_core/common/action.c ****         /* Key and Mods */
 1091               		.loc 1 215 24 is_stmt 0 view .LVU263
 1092 0054 DC2E      		mov r13,r28
 1093 0056 D294      		swap r13
 1094 0058 9FE0      		ldi r25,lo8(15)
 1095 005a D922      		and r13,r25
 215:tmk_core/common/action.c ****         /* Key and Mods */
 1096               		.loc 1 215 5 view .LVU264
 1097 005c ED2D      		mov r30,r13
 1098 005e F0E0      		ldi r31,0
 1099 0060 E050      		subi r30,lo8(-(gs(.L95)))
 1100 0062 F040      		sbci r31,hi8(-(gs(.L95)))
 1101 0064 0C94 0000 		jmp __tablejump2__
 1102               		.section	.jumptables.gcc.process_action,"a",@progbits
 1103               		.p2align	1
 1104               	.L95:
 1105 0000 0000      		.word gs(.L103)
 1106 0002 0000      		.word gs(.L103)
 1107 0004 0000      		.word gs(.L102)
 1108 0006 0000      		.word gs(.L102)
 1109 0008 0000      		.word gs(.L101)
 1110 000a 0000      		.word gs(.L100)
 1111 000c 0000      		.word gs(.L99)
 1112 000e 0000      		.word gs(.L93)
 1113 0010 0000      		.word gs(.L98)
 1114 0012 0000      		.word gs(.L93)
 1115 0014 0000      		.word gs(.L97)
 1116 0016 0000      		.word gs(.L97)
 1117 0018 0000      		.word gs(.L96)
 1118 001a 0000      		.word gs(.L93)
 1119 001c 0000      		.word gs(.L93)
 1120 001e 0000      		.word gs(.L94)
 1121               		.section	.text.process_action
 1122               	.LVL90:
 1123               	.L187:
 207:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 1124               		.loc 1 207 10 view .LVU265
 1125 0068 C12C      		mov r12,__zero_reg__
 1126 006a 00C0      		rjmp .L92
 1127               	.LVL91:
 1128               	.L103:
 1129               	.LBB24:
 220:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 1130               		.loc 1 220 17 is_stmt 1 view .LVU266
 1131 006c 0C2F      		mov r16,r28
 1132               	.LVL92:
 220:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 1133               		.loc 1 220 17 is_stmt 0 view .LVU267
 1134 006e 0F70      		andi r16,lo8(15)
 220:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 1135               		.loc 1 220 48 view .LVU268
 1136 0070 C07F      		andi r28,lo8(-16)
 1137               	.LVL93:
 220:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 1138               		.loc 1 220 25 view .LVU269
 1139 0072 01F0      		breq .L104
 220:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 1140               		.loc 1 220 25 discriminator 2 view .LVU270
 1141 0074 0295      		swap r16
 1142 0076 007F      		andi r16,lo8(-16)
 1143               	.L104:
 1144               	.LVL94:
 222:tmk_core/common/action.c ****                     if (mods) {
 1145               		.loc 1 222 17 is_stmt 1 discriminator 4 view .LVU271
 222:tmk_core/common/action.c ****                     if (mods) {
 1146               		.loc 1 222 20 is_stmt 0 discriminator 4 view .LVU272
 1147 0078 1123      		tst r17
 1148 007a 01F0      		breq .L105
 223:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1149               		.loc 1 223 21 is_stmt 1 view .LVU273
 223:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1150               		.loc 1 223 24 is_stmt 0 view .LVU274
 1151 007c 0023      		tst r16
 1152 007e 01F0      		breq .L242
 224:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 1153               		.loc 1 224 25 is_stmt 1 view .LVU275
 224:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 1154               		.loc 1 224 29 is_stmt 0 view .LVU276
 1155 0080 80E2      		ldi r24,lo8(32)
 1156 0082 8D0F      		add r24,r29
 224:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 1157               		.loc 1 224 28 view .LVU277
 1158 0084 8830      		cpi r24,lo8(8)
 1159 0086 00F0      		brlo .L107
 224:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 1160               		.loc 1 224 53 discriminator 1 view .LVU278
 1161 0088 D111      		cpse r29,__zero_reg__
 1162 008a 00C0      		rjmp .L108
 1163               	.L107:
 228:tmk_core/common/action.c ****                         } else {
 1164               		.loc 1 228 29 is_stmt 1 view .LVU279
 1165 008c 802F      		mov r24,r16
 1166 008e 0E94 0000 		call add_mods
 1167               	.LVL95:
 1168               	.L109:
 232:tmk_core/common/action.c ****                     }
 1169               		.loc 1 232 25 view .LVU280
 1170 0092 0E94 0000 		call send_keyboard_report
 1171               	.LVL96:
 234:tmk_core/common/action.c ****                 } else {
 1172               		.loc 1 234 21 view .LVU281
 1173               	.L242:
 234:tmk_core/common/action.c ****                 } else {
 1174               		.loc 1 234 21 is_stmt 0 view .LVU282
 1175               	.LBE24:
 511:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 1176               		.loc 1 511 75 is_stmt 1 view .LVU283
 512:tmk_core/common/action.c ****                         } else {
 1177               		.loc 1 512 29 view .LVU284
 1178 0096 8D2F      		mov r24,r29
 1179 0098 0E94 0000 		call register_code
 1180               	.LVL97:
 1181 009c 00C0      		rjmp .L93
 1182               	.LVL98:
 1183               	.L108:
 1184               	.LBB25:
 230:tmk_core/common/action.c ****                         }
 1185               		.loc 1 230 29 view .LVU285
 1186 009e 802F      		mov r24,r16
 1187 00a0 0E94 0000 		call add_weak_mods
 1188               	.LVL99:
 1189 00a4 00C0      		rjmp .L109
 1190               	.L105:
 236:tmk_core/common/action.c ****                     if (mods) {
 1191               		.loc 1 236 21 view .LVU286
 1192 00a6 8D2F      		mov r24,r29
 1193 00a8 0E94 0000 		call unregister_code
 1194               	.LVL100:
 237:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1195               		.loc 1 237 21 view .LVU287
 237:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1196               		.loc 1 237 24 is_stmt 0 view .LVU288
 1197 00ac 0023      		tst r16
 1198 00ae 01F0      		breq .L93
 238:tmk_core/common/action.c ****                             del_mods(mods);
 1199               		.loc 1 238 25 is_stmt 1 view .LVU289
 238:tmk_core/common/action.c ****                             del_mods(mods);
 1200               		.loc 1 238 29 is_stmt 0 view .LVU290
 1201 00b0 80E2      		ldi r24,lo8(32)
 1202 00b2 8D0F      		add r24,r29
 238:tmk_core/common/action.c ****                             del_mods(mods);
 1203               		.loc 1 238 28 view .LVU291
 1204 00b4 8830      		cpi r24,lo8(8)
 1205 00b6 00F0      		brlo .L111
 238:tmk_core/common/action.c ****                             del_mods(mods);
 1206               		.loc 1 238 53 discriminator 1 view .LVU292
 1207 00b8 D111      		cpse r29,__zero_reg__
 1208 00ba 00C0      		rjmp .L112
 1209               	.L111:
 239:tmk_core/common/action.c ****                         } else {
 1210               		.loc 1 239 29 is_stmt 1 view .LVU293
 1211 00bc 802F      		mov r24,r16
 1212 00be 0E94 0000 		call del_mods
 1213               	.LVL101:
 1214               	.L113:
 243:tmk_core/common/action.c ****                     }
 1215               		.loc 1 243 25 view .LVU294
 1216 00c2 0E94 0000 		call send_keyboard_report
 1217               	.LVL102:
 1218               	.L93:
 243:tmk_core/common/action.c ****                     }
 1219               		.loc 1 243 25 is_stmt 0 view .LVU295
 1220               	.LBE25:
 641:tmk_core/common/action.c ****         case ACT_LAYER:
 1221               		.loc 1 641 5 is_stmt 1 view .LVU296
 1222 00c6 F8E0      		ldi r31,lo8(8)
 1223 00c8 DF16      		cp r13,r31
 1224 00ca 01F0      		breq .L181
 1225 00cc DF16      		cp r13,r31
 1226 00ce 00F0      		brlo .L182
 1227 00d0 86EF      		ldi r24,lo8(-10)
 1228 00d2 8D0D      		add r24,r13
 1229 00d4 8F70      		andi r24,lo8(15)
 1230 00d6 8230      		cpi r24,lo8(2)
 1231 00d8 00F4      		brsh .L182
 1232               	.L181:
 647:tmk_core/common/action.c ****             break;
 1233               		.loc 1 647 13 view .LVU297
 1234 00da 0E94 0000 		call host_keyboard_leds
 1235               	.LVL103:
 1236 00de 0E94 0000 		call led_set
 1237               	.LVL104:
 648:tmk_core/common/action.c ****         default:
 1238               		.loc 1 648 13 view .LVU298
 1239               	.L182:
 684:tmk_core/common/action.c ****         record->event.pressed = false;
 1240               		.loc 1 684 5 view .LVU299
 684:tmk_core/common/action.c ****         record->event.pressed = false;
 1241               		.loc 1 684 8 is_stmt 0 view .LVU300
 1242 00e2 CC20      		tst r12
 1243 00e4 01F4      		brne .+2
 1244 00e6 00C0      		rjmp .L90
 684:tmk_core/common/action.c ****         record->event.pressed = false;
 1245               		.loc 1 684 33 discriminator 1 view .LVU301
 1246 00e8 0E94 0000 		call get_oneshot_layer_state
 1247               	.LVL105:
 684:tmk_core/common/action.c ****         record->event.pressed = false;
 1248               		.loc 1 684 28 discriminator 1 view .LVU302
 1249 00ec 80FD      		sbrc r24,0
 1250 00ee 00C0      		rjmp .L90
 685:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1251               		.loc 1 685 9 is_stmt 1 view .LVU303
 685:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1252               		.loc 1 685 31 is_stmt 0 view .LVU304
 1253 00f0 F701      		movw r30,r14
 1254 00f2 1282      		std Z+2,__zero_reg__
 686:tmk_core/common/action.c ****         process_record(record);
 1255               		.loc 1 686 9 is_stmt 1 view .LVU305
 1256 00f4 0E94 0000 		call get_oneshot_layer
 1257               	.LVL106:
 1258 00f8 0E94 0000 		call layer_on
 1259               	.LVL107:
 687:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1260               		.loc 1 687 9 view .LVU306
 1261 00fc C701      		movw r24,r14
 1262 00fe 0E94 0000 		call process_record
 1263               	.LVL108:
 688:tmk_core/common/action.c ****     }
 1264               		.loc 1 688 9 view .LVU307
 1265 0102 0E94 0000 		call get_oneshot_layer
 1266               	.LVL109:
 1267               	/* epilogue start */
 691:tmk_core/common/action.c **** 
 1268               		.loc 1 691 1 is_stmt 0 view .LVU308
 1269 0106 DF91      		pop r29
 1270               	.LVL110:
 691:tmk_core/common/action.c **** 
 1271               		.loc 1 691 1 view .LVU309
 1272 0108 CF91      		pop r28
 691:tmk_core/common/action.c **** 
 1273               		.loc 1 691 1 view .LVU310
 1274 010a 1F91      		pop r17
 1275 010c 0F91      		pop r16
 1276 010e FF90      		pop r15
 1277 0110 EF90      		pop r14
 1278               	.LVL111:
 691:tmk_core/common/action.c **** 
 1279               		.loc 1 691 1 view .LVU311
 1280 0112 DF90      		pop r13
 1281 0114 CF90      		pop r12
 1282               	.LVL112:
 691:tmk_core/common/action.c **** 
 1283               		.loc 1 691 1 view .LVU312
 1284 0116 BF90      		pop r11
 1285 0118 AF90      		pop r10
 1286 011a 9F90      		pop r9
 1287 011c 8F90      		pop r8
 688:tmk_core/common/action.c ****     }
 1288               		.loc 1 688 9 view .LVU313
 1289 011e 0C94 0000 		jmp layer_off
 1290               	.LVL113:
 1291               	.L112:
 1292               	.LBB26:
 241:tmk_core/common/action.c ****                         }
 1293               		.loc 1 241 29 is_stmt 1 view .LVU314
 1294 0122 802F      		mov r24,r16
 1295 0124 0E94 0000 		call del_weak_mods
 1296               	.LVL114:
 1297 0128 00C0      		rjmp .L113
 1298               	.LVL115:
 1299               	.L102:
 241:tmk_core/common/action.c ****                         }
 1300               		.loc 1 241 29 is_stmt 0 view .LVU315
 1301               	.LBE26:
 1302               	.LBB27:
 252:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1303               		.loc 1 252 17 is_stmt 1 view .LVU316
 1304 012a FC2F      		mov r31,r28
 1305 012c FF70      		andi r31,lo8(15)
 1306 012e BF2E      		mov r11,r31
 252:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1307               		.loc 1 252 48 is_stmt 0 view .LVU317
 1308 0130 C07F      		andi r28,lo8(-16)
 1309               	.LVL116:
 252:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1310               		.loc 1 252 25 view .LVU318
 1311 0132 C032      		cpi r28,lo8(32)
 1312 0134 01F0      		breq .L114
 252:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1313               		.loc 1 252 25 discriminator 2 view .LVU319
 1314 0136 B294      		swap r11
 1315 0138 80EF      		ldi r24,lo8(-16)
 1316 013a B822      		and r11,r24
 1317               	.L114:
 1318               	.LVL117:
 254:tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 1319               		.loc 1 254 17 is_stmt 1 discriminator 4 view .LVU320
 1320 013c DD23      		tst r29
 1321 013e 01F0      		breq .L115
 1322 0140 D130      		cpi r29,lo8(1)
 1323 0142 01F0      		breq .L116
 309:tmk_core/common/action.c ****                             if (tap_count > 0) {
 1324               		.loc 1 309 25 view .LVU321
 309:tmk_core/common/action.c ****                             if (tap_count > 0) {
 1325               		.loc 1 309 28 is_stmt 0 view .LVU322
 1326 0144 1123      		tst r17
 1327 0146 01F0      		breq .L124
 310:tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1328               		.loc 1 310 29 is_stmt 1 view .LVU323
 310:tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1329               		.loc 1 310 32 is_stmt 0 view .LVU324
 1330 0148 0023      		tst r16
 1331 014a 01F0      		breq .L243
 1332 014c 00C0      		rjmp .L242
 1333               	.L115:
 258:tmk_core/common/action.c ****                             if (tap_count == 0) {
 1334               		.loc 1 258 25 is_stmt 1 view .LVU325
 258:tmk_core/common/action.c ****                             if (tap_count == 0) {
 1335               		.loc 1 258 28 is_stmt 0 view .LVU326
 1336 014e 1123      		tst r17
 1337 0150 01F0      		breq .L118
 259:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 1338               		.loc 1 259 29 is_stmt 1 view .LVU327
 259:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 1339               		.loc 1 259 32 is_stmt 0 view .LVU328
 1340 0152 0111      		cpse r16,__zero_reg__
 1341 0154 00C0      		rjmp .L119
 1342               	.L120:
 273:tmk_core/common/action.c ****                             }
 1343               		.loc 1 273 33 is_stmt 1 view .LVU329
 273:tmk_core/common/action.c ****                             }
 1344               		.loc 1 273 54 is_stmt 0 view .LVU330
 1345 0156 0E94 0000 		call get_oneshot_mods
 1346               	.LVL118:
 273:tmk_core/common/action.c ****                             }
 1347               		.loc 1 273 33 view .LVU331
 1348 015a 8B29      		or r24,r11
 1349               	.LVL119:
 1350               	.L240:
 300:tmk_core/common/action.c ****                             }
 1351               		.loc 1 300 33 view .LVU332
 1352 015c 0E94 0000 		call register_mods
 1353               	.LVL120:
 1354 0160 00C0      		rjmp .L93
 1355               	.LVL121:
 1356               	.L119:
 262:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1357               		.loc 1 262 36 is_stmt 1 view .LVU333
 262:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1358               		.loc 1 262 39 is_stmt 0 view .LVU334
 1359 0162 0130      		cpi r16,lo8(1)
 1360 0164 01F4      		brne .L120
 263:tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 1361               		.loc 1 263 69 is_stmt 1 view .LVU335
 264:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1362               		.loc 1 264 33 view .LVU336
 264:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1363               		.loc 1 264 57 is_stmt 0 view .LVU337
 1364 0166 0E94 0000 		call get_oneshot_mods
 1365               	.LVL122:
 264:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1366               		.loc 1 264 33 view .LVU338
 1367 016a 8B29      		or r24,r11
 1368 016c 0E94 0000 		call set_oneshot_mods
 1369               	.LVL123:
 1370 0170 00C0      		rjmp .L93
 1371               	.L118:
 276:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1372               		.loc 1 276 29 is_stmt 1 view .LVU339
 276:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1373               		.loc 1 276 32 is_stmt 0 view .LVU340
 1374 0172 0111      		cpse r16,__zero_reg__
 1375 0174 00C0      		rjmp .L121
 1376               	.L247:
 291:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1377               		.loc 1 291 33 is_stmt 1 view .LVU341
 1378 0176 0E94 0000 		call clear_oneshot_mods
 1379               	.LVL124:
 292:tmk_core/common/action.c ****                             }
 1380               		.loc 1 292 33 view .LVU342
 1381               	.L126:
 332:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1382               		.loc 1 332 71 view .LVU343
 333:tmk_core/common/action.c ****                             }
 1383               		.loc 1 333 33 view .LVU344
 1384 017a 8B2D      		mov r24,r11
 1385               	.LVL125:
 1386               	.L241:
 333:tmk_core/common/action.c ****                             }
 1387               		.loc 1 333 33 is_stmt 0 view .LVU345
 1388               	.LBE27:
 442:tmk_core/common/action.c ****                     }
 1389               		.loc 1 442 25 view .LVU346
 1390 017c 0E94 0000 		call unregister_mods
 1391               	.LVL126:
 1392 0180 00C0      		rjmp .L93
 1393               	.LVL127:
 1394               	.L121:
 1395               	.LBB28:
 279:tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1396               		.loc 1 279 36 is_stmt 1 view .LVU347
 279:tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1397               		.loc 1 279 39 is_stmt 0 view .LVU348
 1398 0182 0130      		cpi r16,lo8(1)
 1399 0184 01F4      		brne .+2
 1400 0186 00C0      		rjmp .L93
 1401 0188 00C0      		rjmp .L247
 1402               	.L116:
 298:tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1403               		.loc 1 298 25 is_stmt 1 view .LVU349
 298:tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1404               		.loc 1 298 28 is_stmt 0 view .LVU350
 1405 018a 1123      		tst r17
 1406 018c 01F0      		breq .L123
 299:tmk_core/common/action.c ****                                 register_mods(mods);
 1407               		.loc 1 299 29 is_stmt 1 view .LVU351
 299:tmk_core/common/action.c ****                                 register_mods(mods);
 1408               		.loc 1 299 32 is_stmt 0 view .LVU352
 1409 018e 0230      		cpi r16,lo8(2)
 1410 0190 00F0      		brlo .+2
 1411 0192 00C0      		rjmp .L93
 1412               	.L243:
 300:tmk_core/common/action.c ****                             }
 1413               		.loc 1 300 33 is_stmt 1 view .LVU353
 1414 0194 8B2D      		mov r24,r11
 1415 0196 00C0      		rjmp .L240
 1416               	.L123:
 303:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1417               		.loc 1 303 29 view .LVU354
 303:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1418               		.loc 1 303 32 is_stmt 0 view .LVU355
 1419 0198 0111      		cpse r16,__zero_reg__
 1420 019a 00C0      		rjmp .L93
 1421 019c 00C0      		rjmp .L126
 1422               	.L124:
 328:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1423               		.loc 1 328 29 is_stmt 1 view .LVU356
 328:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1424               		.loc 1 328 32 is_stmt 0 view .LVU357
 1425 019e 0023      		tst r16
 1426 01a0 01F0      		breq .L126
 1427               	.LVL128:
 1428               	.L167:
 328:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1429               		.loc 1 328 32 view .LVU358
 1430               	.LBE28:
 523:tmk_core/common/action.c ****                         } else {
 1431               		.loc 1 523 29 is_stmt 1 view .LVU359
 1432 01a2 8D2F      		mov r24,r29
 1433 01a4 0E94 0000 		call unregister_code
 1434               	.LVL129:
 1435 01a8 00C0      		rjmp .L93
 1436               	.L101:
 344:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1437               		.loc 1 344 13 view .LVU360
 344:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1438               		.loc 1 344 33 is_stmt 0 view .LVU361
 1439 01aa 8C2F      		mov r24,r28
 1440 01ac 8695      		lsr r24
 1441 01ae 8695      		lsr r24
 1442 01b0 8370      		andi r24,lo8(3)
 1443 01b2 01F0      		breq .L127
 1444 01b4 8130      		cpi r24,lo8(1)
 1445 01b6 01F0      		breq .+2
 1446 01b8 00C0      		rjmp .L93
 353:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1447               		.loc 1 353 21 is_stmt 1 view .LVU362
 354:tmk_core/common/action.c ****                     } else {
 1448               		.loc 1 354 25 is_stmt 0 view .LVU363
 1449 01ba 8D2F      		mov r24,r29
 1450 01bc 9C2F      		mov r25,r28
 1451 01be 9370      		andi r25,lo8(3)
 353:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1452               		.loc 1 353 24 view .LVU364
 1453 01c0 1111      		cpse r17,__zero_reg__
 1454 01c2 00C0      		rjmp .L244
 356:tmk_core/common/action.c ****                     }
 1455               		.loc 1 356 25 is_stmt 1 view .LVU365
 1456 01c4 90E0      		ldi r25,0
 1457 01c6 80E0      		ldi r24,0
 1458               	.L244:
 1459 01c8 0E94 0000 		call host_consumer_send
 1460               	.LVL130:
 1461 01cc 00C0      		rjmp .L93
 1462               	.L127:
 346:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1463               		.loc 1 346 21 view .LVU366
 347:tmk_core/common/action.c ****                     } else {
 1464               		.loc 1 347 25 is_stmt 0 view .LVU367
 1465 01ce 8D2F      		mov r24,r29
 1466 01d0 9C2F      		mov r25,r28
 1467 01d2 9370      		andi r25,lo8(3)
 346:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1468               		.loc 1 346 24 view .LVU368
 1469 01d4 1111      		cpse r17,__zero_reg__
 1470 01d6 00C0      		rjmp .L236
 349:tmk_core/common/action.c ****                     }
 1471               		.loc 1 349 25 is_stmt 1 view .LVU369
 1472 01d8 90E0      		ldi r25,0
 1473 01da 80E0      		ldi r24,0
 1474               	.L236:
 1475 01dc 0E94 0000 		call host_system_send
 1476               	.LVL131:
 1477 01e0 00C0      		rjmp .L93
 1478               	.L100:
 365:tmk_core/common/action.c ****                 switch (action.key.code) {
 1479               		.loc 1 365 13 view .LVU370
 365:tmk_core/common/action.c ****                 switch (action.key.code) {
 1480               		.loc 1 365 16 is_stmt 0 view .LVU371
 1481 01e2 1123      		tst r17
 1482 01e4 01F0      		breq .L131
 366:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1483               		.loc 1 366 17 is_stmt 1 view .LVU372
 1484 01e6 D53F      		cpi r29,lo8(-11)
 1485 01e8 01F0      		breq .L132
 1486 01ea D63F      		cpi r29,lo8(-10)
 1487 01ec 01F0      		breq .L133
 1488 01ee D43F      		cpi r29,lo8(-12)
 1489 01f0 01F4      		brne .L134
 368:tmk_core/common/action.c ****                         break;
 1490               		.loc 1 368 25 view .LVU373
 368:tmk_core/common/action.c ****                         break;
 1491               		.loc 1 368 36 is_stmt 0 view .LVU374
 1492 01f2 8091 0000 		lds r24,tp_buttons
 1493 01f6 9091 0000 		lds r25,tp_buttons+1
 1494 01fa 8160      		ori r24,1
 1495               	.L230:
 374:tmk_core/common/action.c ****                         break;
 1496               		.loc 1 374 36 view .LVU375
 1497 01fc 9093 0000 		sts tp_buttons+1,r25
 1498 0200 8093 0000 		sts tp_buttons,r24
 375:tmk_core/common/action.c ****                     default:
 1499               		.loc 1 375 25 is_stmt 1 view .LVU376
 1500               	.L134:
 379:tmk_core/common/action.c ****                 mousekey_send();
 1501               		.loc 1 379 17 view .LVU377
 1502 0204 8D2F      		mov r24,r29
 1503 0206 0E94 0000 		call mousekey_on
 1504               	.LVL132:
 380:tmk_core/common/action.c ****             } else {
 1505               		.loc 1 380 17 view .LVU378
 1506               	.L237:
 396:tmk_core/common/action.c ****             }
 1507               		.loc 1 396 17 view .LVU379
 1508 020a 0E94 0000 		call mousekey_send
 1509               	.LVL133:
 1510 020e 00C0      		rjmp .L93
 1511               	.L132:
 371:tmk_core/common/action.c ****                         break;
 1512               		.loc 1 371 25 view .LVU380
 371:tmk_core/common/action.c ****                         break;
 1513               		.loc 1 371 36 is_stmt 0 view .LVU381
 1514 0210 8091 0000 		lds r24,tp_buttons
 1515 0214 9091 0000 		lds r25,tp_buttons+1
 1516 0218 8260      		ori r24,2
 1517 021a 00C0      		rjmp .L230
 1518               	.L133:
 374:tmk_core/common/action.c ****                         break;
 1519               		.loc 1 374 25 is_stmt 1 view .LVU382
 374:tmk_core/common/action.c ****                         break;
 1520               		.loc 1 374 36 is_stmt 0 view .LVU383
 1521 021c 8091 0000 		lds r24,tp_buttons
 1522 0220 9091 0000 		lds r25,tp_buttons+1
 1523 0224 8460      		ori r24,4
 1524 0226 00C0      		rjmp .L230
 1525               	.L131:
 382:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1526               		.loc 1 382 17 is_stmt 1 view .LVU384
 1527 0228 D53F      		cpi r29,lo8(-11)
 1528 022a 01F0      		breq .L135
 1529 022c D63F      		cpi r29,lo8(-10)
 1530 022e 01F0      		breq .L136
 1531 0230 D43F      		cpi r29,lo8(-12)
 1532 0232 01F4      		brne .L137
 384:tmk_core/common/action.c ****                         break;
 1533               		.loc 1 384 25 view .LVU385
 384:tmk_core/common/action.c ****                         break;
 1534               		.loc 1 384 36 is_stmt 0 view .LVU386
 1535 0234 8091 0000 		lds r24,tp_buttons
 1536 0238 9091 0000 		lds r25,tp_buttons+1
 1537 023c 8E7F      		andi r24,254
 1538               	.L231:
 390:tmk_core/common/action.c ****                         break;
 1539               		.loc 1 390 36 view .LVU387
 1540 023e 9093 0000 		sts tp_buttons+1,r25
 1541 0242 8093 0000 		sts tp_buttons,r24
 391:tmk_core/common/action.c ****                     default:
 1542               		.loc 1 391 25 is_stmt 1 view .LVU388
 1543               	.L137:
 395:tmk_core/common/action.c ****                 mousekey_send();
 1544               		.loc 1 395 17 view .LVU389
 1545 0246 8D2F      		mov r24,r29
 1546 0248 0E94 0000 		call mousekey_off
 1547               	.LVL134:
 1548 024c 00C0      		rjmp .L237
 1549               	.L135:
 387:tmk_core/common/action.c ****                         break;
 1550               		.loc 1 387 25 view .LVU390
 387:tmk_core/common/action.c ****                         break;
 1551               		.loc 1 387 36 is_stmt 0 view .LVU391
 1552 024e 8091 0000 		lds r24,tp_buttons
 1553 0252 9091 0000 		lds r25,tp_buttons+1
 1554 0256 8D7F      		andi r24,253
 1555 0258 00C0      		rjmp .L231
 1556               	.L136:
 390:tmk_core/common/action.c ****                         break;
 1557               		.loc 1 390 25 is_stmt 1 view .LVU392
 390:tmk_core/common/action.c ****                         break;
 1558               		.loc 1 390 36 is_stmt 0 view .LVU393
 1559 025a 8091 0000 		lds r24,tp_buttons
 1560 025e 9091 0000 		lds r25,tp_buttons+1
 1561 0262 8B7F      		andi r24,251
 1562 0264 00C0      		rjmp .L231
 1563               	.L98:
 402:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1564               		.loc 1 402 13 is_stmt 1 view .LVU394
 402:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1565               		.loc 1 402 39 is_stmt 0 view .LVU395
 1566 0266 8C2F      		mov r24,r28
 1567 0268 8370      		andi r24,lo8(3)
 402:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1568               		.loc 1 402 16 view .LVU396
 1569 026a 01F0      		breq .+2
 1570 026c 00C0      		rjmp .L138
 404:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1571               		.loc 1 404 17 is_stmt 1 view .LVU397
 404:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1572               		.loc 1 404 20 is_stmt 0 view .LVU398
 1573 026e 1111      		cpse r17,__zero_reg__
 1574 0270 00C0      		rjmp .L93
 1575               	.LBB29:
 405:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1576               		.loc 1 405 21 is_stmt 1 view .LVU399
 1577               	.LVL135:
 406:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1578               		.loc 1 406 21 view .LVU400
 405:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1579               		.loc 1 405 55 is_stmt 0 view .LVU401
 1580 0272 2D2F      		mov r18,r29
 1581 0274 2295      		swap r18
 1582 0276 2695      		lsr r18
 1583 0278 2770      		andi r18,lo8(7)
 405:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1584               		.loc 1 405 29 view .LVU402
 1585 027a 220F      		lsl r18
 1586 027c 220F      		lsl r18
 406:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1587               		.loc 1 406 66 view .LVU403
 1588 027e 6D2F      		mov r22,r29
 1589 0280 6F70      		andi r22,lo8(15)
 406:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1590               		.loc 1 406 38 view .LVU404
 1591 0282 862E      		mov r8,r22
 1592 0284 912C      		mov r9,__zero_reg__
 1593 0286 B12C      		mov r11,__zero_reg__
 1594 0288 A12C      		mov r10,__zero_reg__
 406:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1595               		.loc 1 406 30 view .LVU405
 1596 028a 022E      		mov r0,r18
 1597 028c 00C0      		rjmp 2f
 1598               		1:
 1599 028e 880C      		lsl r8
 1600 0290 991C      		rol r9
 1601 0292 AA1C      		rol r10
 1602 0294 BB1C      		rol r11
 1603               		2:
 1604 0296 0A94      		dec r0
 1605 0298 02F4      		brpl 1b
 1606               	.LVL136:
 407:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1607               		.loc 1 407 21 is_stmt 1 view .LVU406
 407:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1608               		.loc 1 407 91 is_stmt 0 view .LVU407
 1609 029a 60E0      		ldi r22,0
 1610 029c 70E0      		ldi r23,0
 1611 029e CB01      		movw r24,r22
 1612 02a0 D4FF      		sbrs r29,4
 1613 02a2 00C0      		rjmp .L139
 407:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1614               		.loc 1 407 82 discriminator 1 view .LVU408
 1615 02a4 6FE0      		ldi r22,lo8(15)
 1616 02a6 70E0      		ldi r23,0
 1617 02a8 80E0      		ldi r24,0
 1618 02aa 90E0      		ldi r25,0
 1619 02ac 00C0      		rjmp 2f
 1620               		1:
 1621 02ae 660F      		lsl r22
 1622 02b0 771F      		rol r23
 1623 02b2 881F      		rol r24
 1624 02b4 991F      		rol r25
 1625               		2:
 1626 02b6 2A95      		dec r18
 1627 02b8 02F4      		brpl 1b
 407:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1628               		.loc 1 407 91 discriminator 1 view .LVU409
 1629 02ba 6095      		com r22
 1630 02bc 7095      		com r23
 1631 02be 8095      		com r24
 1632 02c0 9095      		com r25
 1633               	.L139:
 1634               	.LVL137:
 408:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1635               		.loc 1 408 21 is_stmt 1 discriminator 4 view .LVU410
 408:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1636               		.loc 1 408 47 is_stmt 0 discriminator 4 view .LVU411
 1637 02c2 C695      		lsr r28
 1638 02c4 C695      		lsr r28
 1639               	.LVL138:
 408:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1640               		.loc 1 408 47 discriminator 4 view .LVU412
 1641 02c6 C370      		andi r28,lo8(3)
 1642 02c8 C230      		cpi r28,lo8(2)
 1643 02ca 01F0      		breq .L140
 1644 02cc 00F4      		brsh .L141
 1645 02ce 6829      		or r22,r8
 1646               	.LVL139:
 408:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1647               		.loc 1 408 47 discriminator 4 view .LVU413
 1648 02d0 7929      		or r23,r9
 1649 02d2 8A29      		or r24,r10
 1650 02d4 9B29      		or r25,r11
 1651 02d6 C130      		cpi r28,lo8(1)
 1652 02d8 01F0      		breq .L245
 409:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1653               		.loc 1 409 42 is_stmt 1 view .LVU414
 1654 02da 0E94 0000 		call default_layer_and
 1655               	.LVL140:
 409:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1656               		.loc 1 409 74 view .LVU415
 409:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1657               		.loc 1 409 25 is_stmt 0 view .LVU416
 1658 02de 00C0      		rjmp .L93
 1659               	.LVL141:
 1660               	.L140:
 411:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1661               		.loc 1 411 42 is_stmt 1 view .LVU417
 1662 02e0 6829      		or r22,r8
 1663               	.LVL142:
 411:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1664               		.loc 1 411 42 is_stmt 0 view .LVU418
 1665 02e2 7929      		or r23,r9
 1666 02e4 8A29      		or r24,r10
 1667 02e6 9B29      		or r25,r11
 1668 02e8 0E94 0000 		call default_layer_xor
 1669               	.LVL143:
 411:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1670               		.loc 1 411 74 is_stmt 1 view .LVU419
 411:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1671               		.loc 1 411 25 is_stmt 0 view .LVU420
 1672 02ec 00C0      		rjmp .L93
 1673               	.LVL144:
 1674               	.L141:
 412:tmk_core/common/action.c ****                     }
 1675               		.loc 1 412 42 is_stmt 1 view .LVU421
 1676 02ee 0E94 0000 		call default_layer_and
 1677               	.LVL145:
 412:tmk_core/common/action.c ****                     }
 1678               		.loc 1 412 67 view .LVU422
 1679 02f2 C501      		movw r24,r10
 1680 02f4 B401      		movw r22,r8
 1681               	.L245:
 1682 02f6 0E94 0000 		call default_layer_or
 1683               	.LVL146:
 412:tmk_core/common/action.c ****                     }
 1684               		.loc 1 412 91 view .LVU423
 412:tmk_core/common/action.c ****                     }
 1685               		.loc 1 412 25 is_stmt 0 view .LVU424
 1686 02fa 00C0      		rjmp .L93
 1687               	.LVL147:
 1688               	.L138:
 412:tmk_core/common/action.c ****                     }
 1689               		.loc 1 412 25 view .LVU425
 1690               	.LBE29:
 417:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1691               		.loc 1 417 17 is_stmt 1 view .LVU426
 417:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1692               		.loc 1 417 21 is_stmt 0 view .LVU427
 1693 02fc 8695      		lsr r24
 1694 02fe 1123      		tst r17
 1695 0300 01F0      		breq .L144
 417:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1696               		.loc 1 417 21 discriminator 1 view .LVU428
 1697 0302 8C2F      		mov r24,r28
 1698 0304 8170      		andi r24,lo8(1)
 1699               	.L144:
 417:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1700               		.loc 1 417 20 discriminator 4 view .LVU429
 1701 0306 8823      		tst r24
 1702 0308 01F4      		brne .+2
 1703 030a 00C0      		rjmp .L93
 1704               	.LBB30:
 419:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1705               		.loc 1 419 21 is_stmt 1 view .LVU430
 1706               	.LVL148:
 420:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1707               		.loc 1 420 21 view .LVU431
 419:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1708               		.loc 1 419 55 is_stmt 0 view .LVU432
 1709 030c 2D2F      		mov r18,r29
 1710 030e 2295      		swap r18
 1711 0310 2695      		lsr r18
 1712 0312 2770      		andi r18,lo8(7)
 419:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1713               		.loc 1 419 29 view .LVU433
 1714 0314 220F      		lsl r18
 1715 0316 220F      		lsl r18
 420:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1716               		.loc 1 420 66 view .LVU434
 1717 0318 6D2F      		mov r22,r29
 1718 031a 6F70      		andi r22,lo8(15)
 420:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1719               		.loc 1 420 38 view .LVU435
 1720 031c 862E      		mov r8,r22
 1721 031e 912C      		mov r9,__zero_reg__
 1722 0320 B12C      		mov r11,__zero_reg__
 1723 0322 A12C      		mov r10,__zero_reg__
 420:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1724               		.loc 1 420 30 view .LVU436
 1725 0324 022E      		mov r0,r18
 1726 0326 00C0      		rjmp 2f
 1727               		1:
 1728 0328 880C      		lsl r8
 1729 032a 991C      		rol r9
 1730 032c AA1C      		rol r10
 1731 032e BB1C      		rol r11
 1732               		2:
 1733 0330 0A94      		dec r0
 1734 0332 02F4      		brpl 1b
 1735               	.LVL149:
 421:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1736               		.loc 1 421 21 is_stmt 1 view .LVU437
 421:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1737               		.loc 1 421 91 is_stmt 0 view .LVU438
 1738 0334 60E0      		ldi r22,0
 1739 0336 70E0      		ldi r23,0
 1740 0338 CB01      		movw r24,r22
 1741 033a D4FF      		sbrs r29,4
 1742 033c 00C0      		rjmp .L145
 421:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1743               		.loc 1 421 82 discriminator 1 view .LVU439
 1744 033e 6FE0      		ldi r22,lo8(15)
 1745 0340 70E0      		ldi r23,0
 1746 0342 80E0      		ldi r24,0
 1747 0344 90E0      		ldi r25,0
 1748 0346 00C0      		rjmp 2f
 1749               		1:
 1750 0348 660F      		lsl r22
 1751 034a 771F      		rol r23
 1752 034c 881F      		rol r24
 1753 034e 991F      		rol r25
 1754               		2:
 1755 0350 2A95      		dec r18
 1756 0352 02F4      		brpl 1b
 421:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1757               		.loc 1 421 91 discriminator 1 view .LVU440
 1758 0354 6095      		com r22
 1759 0356 7095      		com r23
 1760 0358 8095      		com r24
 1761 035a 9095      		com r25
 1762               	.L145:
 1763               	.LVL150:
 422:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1764               		.loc 1 422 21 is_stmt 1 discriminator 4 view .LVU441
 422:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1765               		.loc 1 422 47 is_stmt 0 discriminator 4 view .LVU442
 1766 035c C695      		lsr r28
 1767 035e C695      		lsr r28
 1768               	.LVL151:
 422:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1769               		.loc 1 422 47 discriminator 4 view .LVU443
 1770 0360 C370      		andi r28,lo8(3)
 1771 0362 C230      		cpi r28,lo8(2)
 1772 0364 01F0      		breq .L146
 1773 0366 00F4      		brsh .L147
 1774 0368 6829      		or r22,r8
 1775               	.LVL152:
 422:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1776               		.loc 1 422 47 discriminator 4 view .LVU444
 1777 036a 7929      		or r23,r9
 1778 036c 8A29      		or r24,r10
 1779 036e 9B29      		or r25,r11
 1780 0370 C130      		cpi r28,lo8(1)
 1781 0372 01F0      		breq .L246
 423:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1782               		.loc 1 423 42 is_stmt 1 view .LVU445
 1783 0374 0E94 0000 		call layer_and
 1784               	.LVL153:
 423:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1785               		.loc 1 423 66 view .LVU446
 423:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1786               		.loc 1 423 25 is_stmt 0 view .LVU447
 1787 0378 00C0      		rjmp .L93
 1788               	.LVL154:
 1789               	.L146:
 425:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1790               		.loc 1 425 42 is_stmt 1 view .LVU448
 1791 037a 6829      		or r22,r8
 1792               	.LVL155:
 425:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1793               		.loc 1 425 42 is_stmt 0 view .LVU449
 1794 037c 7929      		or r23,r9
 1795 037e 8A29      		or r24,r10
 1796 0380 9B29      		or r25,r11
 1797 0382 0E94 0000 		call layer_xor
 1798               	.LVL156:
 425:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1799               		.loc 1 425 66 is_stmt 1 view .LVU450
 425:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1800               		.loc 1 425 25 is_stmt 0 view .LVU451
 1801 0386 00C0      		rjmp .L93
 1802               	.LVL157:
 1803               	.L147:
 426:tmk_core/common/action.c ****                     }
 1804               		.loc 1 426 42 is_stmt 1 view .LVU452
 1805 0388 0E94 0000 		call layer_and
 1806               	.LVL158:
 426:tmk_core/common/action.c ****                     }
 1807               		.loc 1 426 59 view .LVU453
 1808 038c C501      		movw r24,r10
 1809 038e B401      		movw r22,r8
 1810               	.L246:
 1811 0390 0E94 0000 		call layer_or
 1812               	.LVL159:
 426:tmk_core/common/action.c ****                     }
 1813               		.loc 1 426 75 view .LVU454
 426:tmk_core/common/action.c ****                     }
 1814               		.loc 1 426 25 is_stmt 0 view .LVU455
 1815 0394 00C0      		rjmp .L93
 1816               	.LVL160:
 1817               	.L97:
 426:tmk_core/common/action.c ****                     }
 1818               		.loc 1 426 25 view .LVU456
 1819               	.LBE30:
 434:tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 1820               		.loc 1 434 13 is_stmt 1 view .LVU457
 1821 0396 E0E2      		ldi r30,lo8(32)
 1822 0398 ED0F      		add r30,r29
 1823 039a E531      		cpi r30,lo8(21)
 1824 039c 00F0      		brlo .+2
 1825 039e 00C0      		rjmp .L149
 1826 03a0 F0E0      		ldi r31,0
 1827 03a2 E050      		subi r30,lo8(-(gs(.L151)))
 1828 03a4 F040      		sbci r31,hi8(-(gs(.L151)))
 1829 03a6 0C94 0000 		jmp __tablejump2__
 1830               		.section	.jumptables.gcc.process_action,"a",@progbits
 1831               		.p2align	1
 1832               	.L151:
 1833 0020 0000      		.word gs(.L156)
 1834 0022 0000      		.word gs(.L156)
 1835 0024 0000      		.word gs(.L156)
 1836 0026 0000      		.word gs(.L156)
 1837 0028 0000      		.word gs(.L156)
 1838 002a 0000      		.word gs(.L156)
 1839 002c 0000      		.word gs(.L156)
 1840 002e 0000      		.word gs(.L156)
 1841 0030 0000      		.word gs(.L156)
 1842 0032 0000      		.word gs(.L156)
 1843 0034 0000      		.word gs(.L156)
 1844 0036 0000      		.word gs(.L156)
 1845 0038 0000      		.word gs(.L156)
 1846 003a 0000      		.word gs(.L156)
 1847 003c 0000      		.word gs(.L156)
 1848 003e 0000      		.word gs(.L156)
 1849 0040 0000      		.word gs(.L155)
 1850 0042 0000      		.word gs(.L154)
 1851 0044 0000      		.word gs(.L153)
 1852 0046 0000      		.word gs(.L152)
 1853 0048 0000      		.word gs(.L150)
 1854               		.section	.text.process_action
 1855               	.L156:
 437:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1856               		.loc 1 437 21 view .LVU458
 1857 03aa DF70      		andi r29,lo8(15)
 1858               	.LVL161:
 437:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1859               		.loc 1 437 21 is_stmt 0 view .LVU459
 1860 03ac 8C2F      		mov r24,r28
 1861 03ae 8F71      		andi r24,lo8(31)
 437:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1862               		.loc 1 437 24 view .LVU460
 1863 03b0 1123      		tst r17
 1864 03b2 01F0      		breq .L157
 438:tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 1865               		.loc 1 438 25 is_stmt 1 view .LVU461
 1866 03b4 0E94 0000 		call layer_on
 1867               	.LVL162:
 439:tmk_core/common/action.c ****                     } else {
 1868               		.loc 1 439 25 view .LVU462
 1869 03b8 8D2F      		mov r24,r29
 1870 03ba 00C0      		rjmp .L240
 1871               	.L157:
 441:tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 1872               		.loc 1 441 25 view .LVU463
 1873 03bc 0E94 0000 		call layer_off
 1874               	.LVL163:
 442:tmk_core/common/action.c ****                     }
 1875               		.loc 1 442 25 view .LVU464
 1876 03c0 8D2F      		mov r24,r29
 1877 03c2 00C0      		rjmp .L241
 1878               	.LVL164:
 1879               	.L155:
 447:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1880               		.loc 1 447 21 view .LVU465
 447:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1881               		.loc 1 447 24 is_stmt 0 view .LVU466
 1882 03c4 1123      		tst r17
 1883 03c6 01F0      		breq .L158
 448:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1884               		.loc 1 448 25 is_stmt 1 view .LVU467
 448:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1885               		.loc 1 448 28 is_stmt 0 view .LVU468
 1886 03c8 0111      		cpse r16,__zero_reg__
 1887 03ca 00C0      		rjmp .L93
 1888               	.L159:
 449:tmk_core/common/action.c ****                         }
 1889               		.loc 1 449 29 is_stmt 1 view .LVU469
 1890 03cc 8C2F      		mov r24,r28
 1891 03ce 8F71      		andi r24,lo8(31)
 1892 03d0 0E94 0000 		call layer_invert
 1893               	.LVL165:
 1894 03d4 00C0      		rjmp .L93
 1895               	.L158:
 452:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1896               		.loc 1 452 25 view .LVU470
 452:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1897               		.loc 1 452 28 is_stmt 0 view .LVU471
 1898 03d6 0230      		cpi r16,lo8(2)
 1899 03d8 00F0      		brlo .+2
 1900 03da 00C0      		rjmp .L93
 1901 03dc 00C0      		rjmp .L159
 1902               	.L154:
 458:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1903               		.loc 1 458 21 is_stmt 1 view .LVU472
 1904 03de 8C2F      		mov r24,r28
 1905 03e0 8F71      		andi r24,lo8(31)
 458:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1906               		.loc 1 458 68 is_stmt 0 view .LVU473
 1907 03e2 1123      		tst r17
 1908 03e4 01F0      		breq .L235
 1909               	.L238:
 515:tmk_core/common/action.c ****                         }
 1910               		.loc 1 515 29 view .LVU474
 1911 03e6 0E94 0000 		call layer_on
 1912               	.LVL166:
 1913 03ea 00C0      		rjmp .L93
 1914               	.L153:
 462:tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1915               		.loc 1 462 21 is_stmt 1 view .LVU475
 1916 03ec 8C2F      		mov r24,r28
 1917 03ee 8F71      		andi r24,lo8(31)
 462:tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1918               		.loc 1 462 69 is_stmt 0 view .LVU476
 1919 03f0 1123      		tst r17
 1920 03f2 01F0      		breq .L238
 1921               	.L235:
 526:tmk_core/common/action.c ****                         }
 1922               		.loc 1 526 29 view .LVU477
 1923 03f4 0E94 0000 		call layer_off
 1924               	.LVL167:
 1925 03f8 00C0      		rjmp .L93
 1926               	.L152:
 466:tmk_core/common/action.c ****                                     layer_clear();
 1927               		.loc 1 466 21 is_stmt 1 view .LVU478
 466:tmk_core/common/action.c ****                                     layer_clear();
 1928               		.loc 1 466 70 is_stmt 0 view .LVU479
 1929 03fa 1123      		tst r17
 1930 03fc 01F0      		breq .L162
 466:tmk_core/common/action.c ****                                     layer_clear();
 1931               		.loc 1 466 37 discriminator 1 view .LVU480
 1932 03fe 8C2F      		mov r24,r28
 1933 0400 8F71      		andi r24,lo8(31)
 1934 0402 0E94 0000 		call layer_move
 1935               	.LVL168:
 1936 0406 00C0      		rjmp .L93
 1937               	.L162:
 467:tmk_core/common/action.c ****                     break;
 1938               		.loc 1 467 37 view .LVU481
 1939 0408 0E94 0000 		call layer_clear
 1940               	.LVL169:
 1941 040c 00C0      		rjmp .L93
 1942               	.L150:
 495:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1943               		.loc 1 495 21 is_stmt 1 view .LVU482
 495:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1944               		.loc 1 495 24 is_stmt 0 view .LVU483
 1945 040e 1123      		tst r17
 1946 0410 01F0      		breq .L163
 496:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1947               		.loc 1 496 25 is_stmt 1 view .LVU484
 496:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1948               		.loc 1 496 50 is_stmt 0 view .LVU485
 1949 0412 CF71      		andi r28,lo8(31)
 1950               	.LVL170:
 496:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1951               		.loc 1 496 25 view .LVU486
 1952 0414 8C2F      		mov r24,r28
 1953 0416 0E94 0000 		call layer_on
 1954               	.LVL171:
 497:tmk_core/common/action.c ****                     } else {
 1955               		.loc 1 497 25 is_stmt 1 view .LVU487
 1956 041a 63E0      		ldi r22,lo8(3)
 1957 041c 8C2F      		mov r24,r28
 1958 041e 0E94 0000 		call set_oneshot_layer
 1959               	.LVL172:
 1960 0422 00C0      		rjmp .L93
 1961               	.LVL173:
 1962               	.L163:
 499:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1963               		.loc 1 499 25 view .LVU488
 1964 0424 81E0      		ldi r24,lo8(1)
 1965 0426 0E94 0000 		call clear_oneshot_layer_state
 1966               	.LVL174:
 500:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1967               		.loc 1 500 25 view .LVU489
 500:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1968               		.loc 1 500 28 is_stmt 0 view .LVU490
 1969 042a 0230      		cpi r16,lo8(2)
 1970 042c 00F4      		brsh .+2
 1971 042e 00C0      		rjmp .L93
 501:tmk_core/common/action.c ****                         }
 1972               		.loc 1 501 29 is_stmt 1 view .LVU491
 1973 0430 82E0      		ldi r24,lo8(2)
 1974 0432 0E94 0000 		call clear_oneshot_layer_state
 1975               	.LVL175:
 1976 0436 00C0      		rjmp .L93
 1977               	.L149:
 509:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1978               		.loc 1 509 21 view .LVU492
 509:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1979               		.loc 1 509 24 is_stmt 0 view .LVU493
 1980 0438 1123      		tst r17
 1981 043a 01F0      		breq .L164
 510:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1982               		.loc 1 510 25 is_stmt 1 view .LVU494
 510:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1983               		.loc 1 510 28 is_stmt 0 view .LVU495
 1984 043c 0111      		cpse r16,__zero_reg__
 1985 043e 00C0      		rjmp .L242
 514:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1986               		.loc 1 514 76 is_stmt 1 view .LVU496
 515:tmk_core/common/action.c ****                         }
 1987               		.loc 1 515 29 view .LVU497
 1988 0440 8C2F      		mov r24,r28
 1989 0442 8F71      		andi r24,lo8(31)
 1990 0444 00C0      		rjmp .L238
 1991               	.L164:
 518:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1992               		.loc 1 518 25 view .LVU498
 518:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1993               		.loc 1 518 28 is_stmt 0 view .LVU499
 1994 0446 0023      		tst r16
 1995 0448 01F0      		breq .L166
 519:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1996               		.loc 1 519 77 is_stmt 1 view .LVU500
 520:tmk_core/common/action.c ****                                 wait_ms(80);
 1997               		.loc 1 520 29 view .LVU501
 520:tmk_core/common/action.c ****                                 wait_ms(80);
 1998               		.loc 1 520 32 is_stmt 0 view .LVU502
 1999 044a D933      		cpi r29,lo8(57)
 2000 044c 01F0      		breq .+2
 2001 044e 00C0      		rjmp .L167
 521:tmk_core/common/action.c ****                             }
 2002               		.loc 1 521 33 is_stmt 1 view .LVU503
 2003               	.LVL176:
 2004               	.LBB31:
 2005               	.LBI31:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2006               		.loc 3 166 1 view .LVU504
 2007               	.LBB32:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2008               		.loc 3 168 2 view .LVU505
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2009               		.loc 3 172 2 view .LVU506
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2010               		.loc 3 173 2 view .LVU507
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2011               		.loc 3 174 2 view .LVU508
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2012               		.loc 3 184 3 view .LVU509
 2013               		.loc 3 187 2 view .LVU510
 2014 0450 2FEF      		ldi r18,lo8(255999)
 2015 0452 87EE      		ldi r24,hi8(255999)
 2016 0454 93E0      		ldi r25,hlo8(255999)
 2017 0456 2150      	1:	subi r18,1
 2018 0458 8040      		sbci r24,0
 2019 045a 9040      		sbci r25,0
 2020 045c 01F4      		brne 1b
 2021 045e 00C0      		rjmp .
 2022 0460 0000      		nop
 2023 0462 00C0      		rjmp .L167
 2024               	.LVL177:
 2025               	.L166:
 2026               		.loc 3 187 2 is_stmt 0 view .LVU511
 2027               	.LBE32:
 2028               	.LBE31:
 525:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 2029               		.loc 1 525 79 is_stmt 1 view .LVU512
 526:tmk_core/common/action.c ****                         }
 2030               		.loc 1 526 29 view .LVU513
 2031 0464 8C2F      		mov r24,r28
 2032 0466 8F71      		andi r24,lo8(31)
 2033 0468 00C0      		rjmp .L235
 2034               	.L96:
 537:tmk_core/common/action.c ****             break;
 2035               		.loc 1 537 13 view .LVU514
 537:tmk_core/common/action.c ****             break;
 2036               		.loc 1 537 83 is_stmt 0 view .LVU515
 2037 046a 4C2F      		mov r20,r28
 2038 046c 4F70      		andi r20,lo8(15)
 537:tmk_core/common/action.c ****             break;
 2039               		.loc 1 537 13 view .LVU516
 2040 046e 6D2F      		mov r22,r29
 2041 0470 C701      		movw r24,r14
 2042 0472 0E94 0000 		call action_get_macro
 2043               	.LVL178:
 2044 0476 0E94 0000 		call action_macro_play
 2045               	.LVL179:
 538:tmk_core/common/action.c **** #endif
 2046               		.loc 1 538 13 is_stmt 1 view .LVU517
 2047 047a 00C0      		rjmp .L93
 2048               	.L99:
 570:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 2049               		.loc 1 570 13 view .LVU518
 2050 047c D23F      		cpi r29,lo8(-14)
 2051 047e 01F0      		breq .L234
 2052 0480 00F4      		brsh .L169
 2053 0482 D03F      		cpi r29,lo8(-16)
 2054 0484 01F0      		breq .L170
 2055 0486 D13F      		cpi r29,lo8(-15)
 2056 0488 01F0      		breq .L171
 2057               	.L172:
 610:tmk_core/common/action.c ****                         if (swap_held) {
 2058               		.loc 1 610 21 view .LVU519
 2059 048a 8091 0000 		lds r24,swap_held
 610:tmk_core/common/action.c ****                         if (swap_held) {
 2060               		.loc 1 610 24 is_stmt 0 view .LVU520
 2061 048e 0023      		tst r16
 2062 0490 01F4      		brne .+2
 2063 0492 00C0      		rjmp .L178
 611:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 2064               		.loc 1 611 25 is_stmt 1 view .LVU521
 611:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 2065               		.loc 1 611 28 is_stmt 0 view .LVU522
 2066 0494 8823      		tst r24
 2067 0496 01F0      		breq .L179
 612:tmk_core/common/action.c ****                             swap_held = false;
 2068               		.loc 1 612 29 is_stmt 1 view .LVU523
 2069 0498 8091 0000 		lds r24,swap_hands
 2070 049c 91E0      		ldi r25,lo8(1)
 2071 049e 8927      		eor r24,r25
 612:tmk_core/common/action.c ****                             swap_held = false;
 2072               		.loc 1 612 40 is_stmt 0 view .LVU524
 2073 04a0 8093 0000 		sts swap_hands,r24
 613:tmk_core/common/action.c ****                         }
 2074               		.loc 1 613 29 is_stmt 1 view .LVU525
 613:tmk_core/common/action.c ****                         }
 2075               		.loc 1 613 39 is_stmt 0 view .LVU526
 2076 04a4 1092 0000 		sts swap_held,__zero_reg__
 2077               	.L179:
 615:tmk_core/common/action.c ****                             register_code(action.swap.code);
 2078               		.loc 1 615 25 is_stmt 1 view .LVU527
 616:tmk_core/common/action.c ****                         } else {
 2079               		.loc 1 616 29 is_stmt 0 view .LVU528
 2080 04a8 8D2F      		mov r24,r29
 615:tmk_core/common/action.c ****                             register_code(action.swap.code);
 2081               		.loc 1 615 28 view .LVU529
 2082 04aa 1123      		tst r17
 2083 04ac 01F0      		breq .L180
 616:tmk_core/common/action.c ****                         } else {
 2084               		.loc 1 616 29 is_stmt 1 view .LVU530
 2085 04ae 0E94 0000 		call register_code
 2086               	.LVL180:
 2087 04b2 00C0      		rjmp .L94
 2088               	.L169:
 2089 04b4 D43F      		cpi r29,lo8(-12)
 2090 04b6 01F0      		breq .L173
 2091 04b8 00F0      		brlo .L174
 2092 04ba D53F      		cpi r29,lo8(-11)
 2093 04bc 01F4      		brne .L172
 583:tmk_core/common/action.c ****                         swap_hands = true;
 2094               		.loc 1 583 21 view .LVU531
 583:tmk_core/common/action.c ****                         swap_hands = true;
 2095               		.loc 1 583 24 is_stmt 0 view .LVU532
 2096 04be 1111      		cpse r17,__zero_reg__
 2097 04c0 00C0      		rjmp .L94
 584:tmk_core/common/action.c ****                     }
 2098               		.loc 1 584 25 is_stmt 1 view .LVU533
 584:tmk_core/common/action.c ****                     }
 2099               		.loc 1 584 36 is_stmt 0 view .LVU534
 2100 04c2 81E0      		ldi r24,lo8(1)
 2101 04c4 00C0      		rjmp .L233
 2102               	.L170:
 572:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 2103               		.loc 1 572 21 is_stmt 1 view .LVU535
 572:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 2104               		.loc 1 572 24 is_stmt 0 view .LVU536
 2105 04c6 1123      		tst r17
 2106 04c8 01F0      		breq .L94
 2107               	.L177:
 573:tmk_core/common/action.c ****                     }
 2108               		.loc 1 573 25 is_stmt 1 view .LVU537
 2109 04ca 8091 0000 		lds r24,swap_hands
 2110 04ce 91E0      		ldi r25,lo8(1)
 2111 04d0 8927      		eor r24,r25
 2112               	.L233:
 584:tmk_core/common/action.c ****                     }
 2113               		.loc 1 584 36 is_stmt 0 view .LVU538
 2114 04d2 8093 0000 		sts swap_hands,r24
 2115 04d6 00C0      		rjmp .L94
 2116               	.L174:
 580:tmk_core/common/action.c ****                     break;
 2117               		.loc 1 580 21 is_stmt 1 view .LVU539
 2118 04d8 81E0      		ldi r24,lo8(1)
 2119 04da 1827      		eor r17,r24
 2120               	.LVL181:
 2121               	.L234:
 580:tmk_core/common/action.c ****                     break;
 2122               		.loc 1 580 32 is_stmt 0 view .LVU540
 2123 04dc 1093 0000 		sts swap_hands,r17
 581:tmk_core/common/action.c ****                 case OP_SH_ON:
 2124               		.loc 1 581 21 is_stmt 1 view .LVU541
 2125               	.L94:
 632:tmk_core/common/action.c ****             break;
 2126               		.loc 1 632 13 view .LVU542
 632:tmk_core/common/action.c ****             break;
 2127               		.loc 1 632 64 is_stmt 0 view .LVU543
 2128 04e0 4C2F      		mov r20,r28
 2129 04e2 4F70      		andi r20,lo8(15)
 632:tmk_core/common/action.c ****             break;
 2130               		.loc 1 632 13 view .LVU544
 2131 04e4 6D2F      		mov r22,r29
 2132 04e6 C701      		movw r24,r14
 2133 04e8 0E94 0000 		call action_function
 2134               	.LVL182:
 633:tmk_core/common/action.c **** #endif
 2135               		.loc 1 633 13 is_stmt 1 view .LVU545
 2136 04ec 00C0      		rjmp .L93
 2137               	.LVL183:
 2138               	.L173:
 588:tmk_core/common/action.c ****                         swap_hands = false;
 2139               		.loc 1 588 21 view .LVU546
 588:tmk_core/common/action.c ****                         swap_hands = false;
 2140               		.loc 1 588 24 is_stmt 0 view .LVU547
 2141 04ee 1111      		cpse r17,__zero_reg__
 2142 04f0 00C0      		rjmp .L94
 589:tmk_core/common/action.c ****                     }
 2143               		.loc 1 589 25 is_stmt 1 view .LVU548
 589:tmk_core/common/action.c ****                     }
 2144               		.loc 1 589 36 is_stmt 0 view .LVU549
 2145 04f2 1092 0000 		sts swap_hands,__zero_reg__
 2146 04f6 00C0      		rjmp .L94
 2147               	.L171:
 596:tmk_core/common/action.c ****                         if (swap_held) {
 2148               		.loc 1 596 21 is_stmt 1 view .LVU550
 596:tmk_core/common/action.c ****                         if (swap_held) {
 2149               		.loc 1 596 24 is_stmt 0 view .LVU551
 2150 04f8 1123      		tst r17
 2151 04fa 01F0      		breq .L176
 597:tmk_core/common/action.c ****                             swap_held = false;
 2152               		.loc 1 597 25 is_stmt 1 view .LVU552
 597:tmk_core/common/action.c ****                             swap_held = false;
 2153               		.loc 1 597 28 is_stmt 0 view .LVU553
 2154 04fc 8091 0000 		lds r24,swap_held
 2155 0500 8823      		tst r24
 2156 0502 01F0      		breq .L177
 2157               	.L232:
 624:tmk_core/common/action.c ****                         }
 2158               		.loc 1 624 29 is_stmt 1 view .LVU554
 624:tmk_core/common/action.c ****                         }
 2159               		.loc 1 624 39 is_stmt 0 view .LVU555
 2160 0504 1092 0000 		sts swap_held,__zero_reg__
 2161 0508 00C0      		rjmp .L94
 2162               	.L176:
 603:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 2163               		.loc 1 603 25 is_stmt 1 view .LVU556
 603:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 2164               		.loc 1 603 28 is_stmt 0 view .LVU557
 2165 050a 0023      		tst r16
 2166 050c 01F0      		breq .L177
 2167 050e 00C0      		rjmp .L94
 2168               	.L180:
 618:tmk_core/common/action.c ****                             *record = (keyrecord_t){}; // hack: reset tap mode
 2169               		.loc 1 618 29 is_stmt 1 view .LVU558
 2170 0510 0E94 0000 		call unregister_code
 2171               	.LVL184:
 619:tmk_core/common/action.c ****                         }
 2172               		.loc 1 619 29 view .LVU559
 619:tmk_core/common/action.c ****                         }
 2173               		.loc 1 619 37 is_stmt 0 view .LVU560
 2174 0514 86E0      		ldi r24,lo8(6)
 2175 0516 F701      		movw r30,r14
 2176               		0:
 2177 0518 1192      		st Z+,__zero_reg__
 2178 051a 8A95      		dec r24
 2179 051c 01F4      		brne 0b
 2180 051e 00C0      		rjmp .L94
 2181               	.L178:
 622:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 2182               		.loc 1 622 25 is_stmt 1 view .LVU561
 622:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 2183               		.loc 1 622 28 is_stmt 0 view .LVU562
 2184 0520 8823      		tst r24
 2185 0522 01F0      		breq .L94
 622:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 2186               		.loc 1 622 39 discriminator 1 view .LVU563
 2187 0524 1111      		cpse r17,__zero_reg__
 2188 0526 00C0      		rjmp .L94
 623:tmk_core/common/action.c ****                             swap_held = false;
 2189               		.loc 1 623 29 is_stmt 1 view .LVU564
 2190 0528 8091 0000 		lds r24,swap_hands
 2191 052c 91E0      		ldi r25,lo8(1)
 2192 052e 8927      		eor r24,r25
 623:tmk_core/common/action.c ****                             swap_held = false;
 2193               		.loc 1 623 40 is_stmt 0 view .LVU565
 2194 0530 8093 0000 		sts swap_hands,r24
 2195 0534 00C0      		rjmp .L232
 2196               	.LVL185:
 2197               	.L90:
 2198               	/* epilogue start */
 691:tmk_core/common/action.c **** 
 2199               		.loc 1 691 1 view .LVU566
 2200 0536 DF91      		pop r29
 2201               	.LVL186:
 691:tmk_core/common/action.c **** 
 2202               		.loc 1 691 1 view .LVU567
 2203 0538 CF91      		pop r28
 691:tmk_core/common/action.c **** 
 2204               		.loc 1 691 1 view .LVU568
 2205 053a 1F91      		pop r17
 2206 053c 0F91      		pop r16
 2207 053e FF90      		pop r15
 2208 0540 EF90      		pop r14
 2209               	.LVL187:
 691:tmk_core/common/action.c **** 
 2210               		.loc 1 691 1 view .LVU569
 2211 0542 DF90      		pop r13
 2212 0544 CF90      		pop r12
 2213               	.LVL188:
 691:tmk_core/common/action.c **** 
 2214               		.loc 1 691 1 view .LVU570
 2215 0546 BF90      		pop r11
 2216 0548 AF90      		pop r10
 2217 054a 9F90      		pop r9
 2218 054c 8F90      		pop r8
 2219 054e 0895      		ret
 2220               		.cfi_endproc
 2221               	.LFE112:
 2223               		.section	.text.process_record,"ax",@progbits
 2224               	.global	process_record
 2226               	process_record:
 2227               	.LVL189:
 2228               	.LFB111:
 173:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 2229               		.loc 1 173 1 is_stmt 1 view -0
 2230               		.cfi_startproc
 173:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 2231               		.loc 1 173 1 is_stmt 0 view .LVU572
 2232 0000 0F93      		push r16
 2233               	.LCFI20:
 2234               		.cfi_def_cfa_offset 3
 2235               		.cfi_offset 16, -2
 2236 0002 1F93      		push r17
 2237               	.LCFI21:
 2238               		.cfi_def_cfa_offset 4
 2239               		.cfi_offset 17, -3
 2240 0004 CF93      		push r28
 2241               	.LCFI22:
 2242               		.cfi_def_cfa_offset 5
 2243               		.cfi_offset 28, -4
 2244 0006 DF93      		push r29
 2245               	.LCFI23:
 2246               		.cfi_def_cfa_offset 6
 2247               		.cfi_offset 29, -5
 2248               	/* prologue: function */
 2249               	/* frame size = 0 */
 2250               	/* stack size = 4 */
 2251               	.L__stack_usage = 4
 2252 0008 EC01      		movw r28,r24
 174:tmk_core/common/action.c **** 
 2253               		.loc 1 174 5 is_stmt 1 view .LVU573
 2254               	.LBB35:
 2255               	.LBI35:
 2256               		.loc 2 49 20 view .LVU574
 2257               	.LBB36:
 2258               		.loc 2 49 51 view .LVU575
 2259               		.loc 2 49 74 is_stmt 0 view .LVU576
 2260 000a 8B81      		ldd r24,Y+3
 2261 000c 9C81      		ldd r25,Y+4
 2262               	.LVL190:
 2263               		.loc 2 49 74 view .LVU577
 2264 000e 892B      		or r24,r25
 2265 0010 01F0      		breq .L248
 2266 0012 8881      		ld r24,Y
 2267 0014 9981      		ldd r25,Y+1
 2268 0016 8923      		and r24,r25
 2269 0018 8F3F      		cpi r24,lo8(-1)
 2270 001a 01F4      		brne .L258
 2271               	.L248:
 2272               	/* epilogue start */
 2273               	.LBE36:
 2274               	.LBE35:
 188:tmk_core/common/action.c **** 
 2275               		.loc 1 188 1 view .LVU578
 2276 001c DF91      		pop r29
 2277 001e CF91      		pop r28
 2278               	.LVL191:
 188:tmk_core/common/action.c **** 
 2279               		.loc 1 188 1 view .LVU579
 2280 0020 1F91      		pop r17
 2281 0022 0F91      		pop r16
 2282 0024 0895      		ret
 2283               	.LVL192:
 2284               	.L258:
 176:tmk_core/common/action.c ****         return;
 2285               		.loc 1 176 5 is_stmt 1 view .LVU580
 176:tmk_core/common/action.c ****         return;
 2286               		.loc 1 176 9 is_stmt 0 view .LVU581
 2287 0026 CE01      		movw r24,r28
 2288 0028 0E94 0000 		call process_record_quantum
 2289               	.LVL193:
 176:tmk_core/common/action.c ****         return;
 2290               		.loc 1 176 7 view .LVU582
 2291 002c 8823      		tst r24
 2292 002e 01F0      		breq .L248
 179:tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 2293               		.loc 1 179 5 is_stmt 1 view .LVU583
 179:tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 2294               		.loc 1 179 23 is_stmt 0 view .LVU584
 2295 0030 6881      		ld r22,Y
 2296 0032 7981      		ldd r23,Y+1
 2297 0034 8A81      		ldd r24,Y+2
 2298 0036 0E94 0000 		call store_or_get_action
 2299               	.LVL194:
 2300 003a 8C01      		movw r16,r24
 2301               	.LVL195:
 180:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 2302               		.loc 1 180 23 is_stmt 1 view .LVU585
 180:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 2303               		.loc 1 180 25 view .LVU586
 182:tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 2304               		.loc 1 182 29 view .LVU587
 182:tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 2305               		.loc 1 182 31 view .LVU588
 2306 003c 0E94 0000 		call layer_debug
 2307               	.LVL196:
 183:tmk_core/common/action.c **** #endif
 2308               		.loc 1 183 37 view .LVU589
 183:tmk_core/common/action.c **** #endif
 2309               		.loc 1 183 39 view .LVU590
 2310 0040 0E94 0000 		call default_layer_debug
 2311               	.LVL197:
 185:tmk_core/common/action.c **** 
 2312               		.loc 1 185 15 view .LVU591
 187:tmk_core/common/action.c **** }
 2313               		.loc 1 187 5 view .LVU592
 187:tmk_core/common/action.c **** }
 2314               		.loc 1 187 5 is_stmt 0 view .LVU593
 2315 0044 B801      		movw r22,r16
 2316 0046 CE01      		movw r24,r28
 2317               	/* epilogue start */
 188:tmk_core/common/action.c **** 
 2318               		.loc 1 188 1 view .LVU594
 2319 0048 DF91      		pop r29
 2320 004a CF91      		pop r28
 2321               	.LVL198:
 188:tmk_core/common/action.c **** 
 2322               		.loc 1 188 1 view .LVU595
 2323 004c 1F91      		pop r17
 2324 004e 0F91      		pop r16
 2325               	.LVL199:
 187:tmk_core/common/action.c **** }
 2326               		.loc 1 187 5 view .LVU596
 2327 0050 0C94 0000 		jmp process_action
 2328               	.LVL200:
 187:tmk_core/common/action.c **** }
 2329               		.loc 1 187 5 view .LVU597
 2330               		.cfi_endproc
 2331               	.LFE111:
 2333               		.section	.text.process_record_nocache,"ax",@progbits
 2334               	.global	process_record_nocache
 2336               	process_record_nocache:
 2337               	.LVL201:
 2338               	.LFB108:
 127:tmk_core/common/action.c ****     disable_action_cache = true;
 2339               		.loc 1 127 1 is_stmt 1 view -0
 2340               		.cfi_startproc
 2341               	/* prologue: function */
 2342               	/* frame size = 0 */
 2343               	/* stack size = 0 */
 2344               	.L__stack_usage = 0
 128:tmk_core/common/action.c ****     process_record(record);
 2345               		.loc 1 128 5 view .LVU599
 128:tmk_core/common/action.c ****     process_record(record);
 2346               		.loc 1 128 26 is_stmt 0 view .LVU600
 2347 0000 21E0      		ldi r18,lo8(1)
 2348 0002 2093 0000 		sts disable_action_cache,r18
 129:tmk_core/common/action.c ****     disable_action_cache = false;
 2349               		.loc 1 129 5 is_stmt 1 view .LVU601
 2350 0006 0E94 0000 		call process_record
 2351               	.LVL202:
 130:tmk_core/common/action.c **** }
 2352               		.loc 1 130 5 view .LVU602
 130:tmk_core/common/action.c **** }
 2353               		.loc 1 130 26 is_stmt 0 view .LVU603
 2354 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2355               	/* epilogue start */
 131:tmk_core/common/action.c **** #else
 2356               		.loc 1 131 1 view .LVU604
 2357 000e 0895      		ret
 2358               		.cfi_endproc
 2359               	.LFE108:
 2361               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2362               	.global	clear_keyboard_but_mods_and_keys
 2364               	clear_keyboard_but_mods_and_keys:
 2365               	.LFB120:
 885:tmk_core/common/action.c **** 
 886:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 887:tmk_core/common/action.c ****  *
 888:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 889:tmk_core/common/action.c ****  */
 890:tmk_core/common/action.c **** void clear_keyboard(void)
 891:tmk_core/common/action.c **** {
 892:tmk_core/common/action.c ****     clear_mods();
 893:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 894:tmk_core/common/action.c **** }
 895:tmk_core/common/action.c **** 
 896:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 897:tmk_core/common/action.c ****  *
 898:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 899:tmk_core/common/action.c ****  */
 900:tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 901:tmk_core/common/action.c **** {
 902:tmk_core/common/action.c ****     clear_keys();
 903:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 904:tmk_core/common/action.c **** }
 905:tmk_core/common/action.c **** 
 906:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 907:tmk_core/common/action.c ****  *
 908:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 909:tmk_core/common/action.c ****  */
 910:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys()
 911:tmk_core/common/action.c **** {
 2366               		.loc 1 911 1 is_stmt 1 view -0
 2367               		.cfi_startproc
 2368               	/* prologue: function */
 2369               	/* frame size = 0 */
 2370               	/* stack size = 0 */
 2371               	.L__stack_usage = 0
 912:tmk_core/common/action.c ****     clear_weak_mods();
 2372               		.loc 1 912 5 view .LVU606
 2373 0000 0E94 0000 		call clear_weak_mods
 2374               	.LVL203:
 913:tmk_core/common/action.c ****     clear_macro_mods();
 2375               		.loc 1 913 5 view .LVU607
 2376 0004 0E94 0000 		call clear_macro_mods
 2377               	.LVL204:
 914:tmk_core/common/action.c ****     send_keyboard_report();
 2378               		.loc 1 914 5 view .LVU608
 2379 0008 0E94 0000 		call send_keyboard_report
 2380               	.LVL205:
 915:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 916:tmk_core/common/action.c ****     mousekey_clear();
 2381               		.loc 1 916 5 view .LVU609
 2382 000c 0E94 0000 		call mousekey_clear
 2383               	.LVL206:
 917:tmk_core/common/action.c ****     mousekey_send();
 2384               		.loc 1 917 5 view .LVU610
 2385 0010 0E94 0000 		call mousekey_send
 2386               	.LVL207:
 918:tmk_core/common/action.c **** #endif
 919:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 920:tmk_core/common/action.c ****     host_system_send(0);
 2387               		.loc 1 920 5 view .LVU611
 2388 0014 90E0      		ldi r25,0
 2389 0016 80E0      		ldi r24,0
 2390 0018 0E94 0000 		call host_system_send
 2391               	.LVL208:
 921:tmk_core/common/action.c ****     host_consumer_send(0);
 2392               		.loc 1 921 5 view .LVU612
 2393 001c 90E0      		ldi r25,0
 2394 001e 80E0      		ldi r24,0
 2395 0020 0C94 0000 		jmp host_consumer_send
 2396               	.LVL209:
 2397               		.cfi_endproc
 2398               	.LFE120:
 2400               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2401               	.global	clear_keyboard_but_mods
 2403               	clear_keyboard_but_mods:
 2404               	.LFB119:
 901:tmk_core/common/action.c ****     clear_keys();
 2405               		.loc 1 901 1 view -0
 2406               		.cfi_startproc
 2407               	/* prologue: function */
 2408               	/* frame size = 0 */
 2409               	/* stack size = 0 */
 2410               	.L__stack_usage = 0
 902:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 2411               		.loc 1 902 5 view .LVU614
 2412 0000 0E94 0000 		call clear_keys
 2413               	.LVL210:
 903:tmk_core/common/action.c **** }
 2414               		.loc 1 903 5 view .LVU615
 2415 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2416               	.LVL211:
 2417               		.cfi_endproc
 2418               	.LFE119:
 2420               		.section	.text.clear_keyboard,"ax",@progbits
 2421               	.global	clear_keyboard
 2423               	clear_keyboard:
 2424               	.LFB118:
 891:tmk_core/common/action.c ****     clear_mods();
 2425               		.loc 1 891 1 view -0
 2426               		.cfi_startproc
 2427               	/* prologue: function */
 2428               	/* frame size = 0 */
 2429               	/* stack size = 0 */
 2430               	.L__stack_usage = 0
 892:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2431               		.loc 1 892 5 view .LVU617
 2432 0000 0E94 0000 		call clear_mods
 2433               	.LVL212:
 893:tmk_core/common/action.c **** }
 2434               		.loc 1 893 5 view .LVU618
 2435 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2436               	.LVL213:
 2437               		.cfi_endproc
 2438               	.LFE118:
 2440               		.section	.text.is_tap_action,"ax",@progbits
 2441               	.global	is_tap_action
 2443               	is_tap_action:
 2444               	.LVL214:
 2445               	.LFB122:
 922:tmk_core/common/action.c **** #endif
 923:tmk_core/common/action.c **** }
 924:tmk_core/common/action.c **** 
 925:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 926:tmk_core/common/action.c ****  *
 927:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 928:tmk_core/common/action.c ****  */
 929:tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 930:tmk_core/common/action.c **** {
 931:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 932:tmk_core/common/action.c ****     return is_tap_action(action);
 933:tmk_core/common/action.c **** }
 934:tmk_core/common/action.c **** 
 935:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 936:tmk_core/common/action.c ****  *
 937:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 938:tmk_core/common/action.c ****  */
 939:tmk_core/common/action.c **** bool is_tap_action(action_t action)
 940:tmk_core/common/action.c **** {
 2446               		.loc 1 940 1 view -0
 2447               		.cfi_startproc
 2448               	/* prologue: function */
 2449               	/* frame size = 0 */
 2450               	/* stack size = 0 */
 2451               	.L__stack_usage = 0
 941:tmk_core/common/action.c ****     switch (action.kind.id) {
 2452               		.loc 1 941 5 view .LVU620
 2453               		.loc 1 941 24 is_stmt 0 view .LVU621
 2454 0000 E92F      		mov r30,r25
 2455 0002 E295      		swap r30
 2456 0004 EF70      		andi r30,lo8(15)
 2457               		.loc 1 941 5 view .LVU622
 2458 0006 E250      		subi r30,lo8(-(-2))
 2459 0008 EE30      		cpi r30,lo8(14)
 2460 000a 00F4      		brsh .L272
 2461 000c F0E0      		ldi r31,0
 2462 000e E050      		subi r30,lo8(-(gs(.L266)))
 2463 0010 F040      		sbci r31,hi8(-(gs(.L266)))
 2464 0012 0C94 0000 		jmp __tablejump2__
 2465               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2466               		.p2align	1
 2467               	.L266:
 2468 0000 0000      		.word gs(.L267)
 2469 0002 0000      		.word gs(.L267)
 2470 0004 0000      		.word gs(.L272)
 2471 0006 0000      		.word gs(.L272)
 2472 0008 0000      		.word gs(.L268)
 2473 000a 0000      		.word gs(.L272)
 2474 000c 0000      		.word gs(.L272)
 2475 000e 0000      		.word gs(.L272)
 2476 0010 0000      		.word gs(.L267)
 2477 0012 0000      		.word gs(.L267)
 2478 0014 0000      		.word gs(.L265)
 2479 0016 0000      		.word gs(.L272)
 2480 0018 0000      		.word gs(.L272)
 2481 001a 0000      		.word gs(.L265)
 2482               		.section	.text.is_tap_action
 2483               	.L267:
 942:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 943:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 944:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 945:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 946:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2484               		.loc 1 946 13 is_stmt 1 view .LVU623
 2485 0016 803F      		cpi r24,lo8(-16)
 2486 0018 01F0      		breq .L275
 2487 001a 00F4      		brsh .L269
 2488 001c 803E      		cpi r24,lo8(-32)
 2489 001e 00F4      		brsh .L272
 2490               	.L275:
 947:tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 948:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 949:tmk_core/common/action.c ****                 case OP_ONESHOT:
 950:tmk_core/common/action.c ****                     return true;
 2491               		.loc 1 950 28 is_stmt 0 view .LVU624
 2492 0020 81E0      		ldi r24,lo8(1)
 2493               	.LVL215:
 2494               	/* epilogue start */
 951:tmk_core/common/action.c ****             }
 952:tmk_core/common/action.c ****             return false;
 953:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 954:tmk_core/common/action.c ****             switch (action.swap.code) {
 955:tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 956:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 957:tmk_core/common/action.c ****                     return true;
 958:tmk_core/common/action.c ****             }
 959:tmk_core/common/action.c ****             return false;
 960:tmk_core/common/action.c ****         case ACT_MACRO:
 961:tmk_core/common/action.c ****         case ACT_FUNCTION:
 962:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 963:tmk_core/common/action.c ****             return false;
 964:tmk_core/common/action.c ****     }
 965:tmk_core/common/action.c ****     return false;
 966:tmk_core/common/action.c **** }
 2495               		.loc 1 966 1 view .LVU625
 2496 0022 0895      		ret
 2497               	.LVL216:
 2498               	.L269:
 2499               		.loc 1 966 1 view .LVU626
 2500 0024 843F      		cpi r24,lo8(-12)
 2501 0026 01F0      		breq .L275
 2502               	.L272:
 952:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2503               		.loc 1 952 20 view .LVU627
 2504 0028 80E0      		ldi r24,0
 2505               	.LVL217:
 952:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2506               		.loc 1 952 20 view .LVU628
 2507 002a 0895      		ret
 2508               	.LVL218:
 2509               	.L268:
 954:tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 2510               		.loc 1 954 13 is_stmt 1 view .LVU629
 2511 002c 803E      		cpi r24,lo8(-32)
 2512 002e 00F0      		brlo .L275
 2513 0030 813F      		cpi r24,lo8(-15)
 2514 0032 01F4      		brne .L272
 2515 0034 00C0      		rjmp .L275
 2516               	.L265:
 962:tmk_core/common/action.c ****             return false;
 2517               		.loc 1 962 13 view .LVU630
 962:tmk_core/common/action.c ****             return false;
 2518               		.loc 1 962 16 is_stmt 0 view .LVU631
 2519 0036 93FB      		bst r25,3
 2520 0038 8827      		clr r24
 2521 003a 80F9      		bld r24,0
 2522               	.LVL219:
 962:tmk_core/common/action.c ****             return false;
 2523               		.loc 1 962 16 view .LVU632
 2524 003c 0895      		ret
 2525               		.cfi_endproc
 2526               	.LFE122:
 2528               		.section	.text.is_tap_key,"ax",@progbits
 2529               	.global	is_tap_key
 2531               	is_tap_key:
 2532               	.LVL220:
 2533               	.LFB121:
 930:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2534               		.loc 1 930 1 is_stmt 1 view -0
 2535               		.cfi_startproc
 2536               	/* prologue: function */
 2537               	/* frame size = 0 */
 2538               	/* stack size = 0 */
 2539               	.L__stack_usage = 0
 931:tmk_core/common/action.c ****     return is_tap_action(action);
 2540               		.loc 1 931 5 view .LVU634
 931:tmk_core/common/action.c ****     return is_tap_action(action);
 2541               		.loc 1 931 23 is_stmt 0 view .LVU635
 2542 0000 0E94 0000 		call layer_switch_get_action
 2543               	.LVL221:
 932:tmk_core/common/action.c **** }
 2544               		.loc 1 932 5 is_stmt 1 view .LVU636
 932:tmk_core/common/action.c **** }
 2545               		.loc 1 932 12 is_stmt 0 view .LVU637
 2546 0004 0C94 0000 		jmp is_tap_action
 2547               	.LVL222:
 2548               		.cfi_endproc
 2549               	.LFE121:
 2551               		.section	.text.debug_event,"ax",@progbits
 2552               	.global	debug_event
 2554               	debug_event:
 2555               	.LFB123:
 967:tmk_core/common/action.c **** 
 968:tmk_core/common/action.c **** 
 969:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 970:tmk_core/common/action.c ****  *
 971:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 972:tmk_core/common/action.c ****  */
 973:tmk_core/common/action.c **** void debug_event(keyevent_t event)
 974:tmk_core/common/action.c **** {
 2556               		.loc 1 974 1 is_stmt 1 view -0
 2557               		.cfi_startproc
 2558 0000 CF93      		push r28
 2559               	.LCFI24:
 2560               		.cfi_def_cfa_offset 3
 2561               		.cfi_offset 28, -2
 2562 0002 DF93      		push r29
 2563               	.LCFI25:
 2564               		.cfi_def_cfa_offset 4
 2565               		.cfi_offset 29, -3
 2566 0004 00D0      		rcall .
 2567 0006 00D0      		rcall .
 2568 0008 0F92      		push __tmp_reg__
 2569               	.LCFI26:
 2570               		.cfi_def_cfa_offset 9
 2571 000a CDB7      		in r28,__SP_L__
 2572 000c DEB7      		in r29,__SP_H__
 2573               	.LCFI27:
 2574               		.cfi_def_cfa_register 28
 2575               	/* prologue: function */
 2576               	/* frame size = 5 */
 2577               	/* stack size = 7 */
 2578               	.L__stack_usage = 7
 975:tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 2579               		.loc 1 975 103 view .LVU639
 2580               	/* epilogue start */
 976:tmk_core/common/action.c **** }
 2581               		.loc 1 976 1 is_stmt 0 view .LVU640
 2582 000e 0F90      		pop __tmp_reg__
 2583 0010 0F90      		pop __tmp_reg__
 2584 0012 0F90      		pop __tmp_reg__
 2585 0014 0F90      		pop __tmp_reg__
 2586 0016 0F90      		pop __tmp_reg__
 2587 0018 DF91      		pop r29
 2588 001a CF91      		pop r28
 2589 001c 0895      		ret
 2590               		.cfi_endproc
 2591               	.LFE123:
 2593               		.section	.text.debug_record,"ax",@progbits
 2594               	.global	debug_record
 2596               	debug_record:
 2597               	.LFB124:
 977:tmk_core/common/action.c **** 
 978:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 979:tmk_core/common/action.c ****  *
 980:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 981:tmk_core/common/action.c ****  */
 982:tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 983:tmk_core/common/action.c **** {
 2598               		.loc 1 983 1 is_stmt 1 view -0
 2599               		.cfi_startproc
 2600 0000 CF93      		push r28
 2601               	.LCFI28:
 2602               		.cfi_def_cfa_offset 3
 2603               		.cfi_offset 28, -2
 2604 0002 DF93      		push r29
 2605               	.LCFI29:
 2606               		.cfi_def_cfa_offset 4
 2607               		.cfi_offset 29, -3
 2608 0004 00D0      		rcall .
 2609 0006 00D0      		rcall .
 2610 0008 00D0      		rcall .
 2611               	.LCFI30:
 2612               		.cfi_def_cfa_offset 10
 2613 000a CDB7      		in r28,__SP_L__
 2614 000c DEB7      		in r29,__SP_H__
 2615               	.LCFI31:
 2616               		.cfi_def_cfa_register 28
 2617               	/* prologue: function */
 2618               	/* frame size = 6 */
 2619               	/* stack size = 8 */
 2620               	.L__stack_usage = 8
 984:tmk_core/common/action.c ****     debug_event(record.event);
 2621               		.loc 1 984 5 view .LVU642
 985:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 986:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2622               		.loc 1 986 77 view .LVU643
 2623               	/* epilogue start */
 987:tmk_core/common/action.c **** #endif
 988:tmk_core/common/action.c **** }
 2624               		.loc 1 988 1 is_stmt 0 view .LVU644
 2625 000e 2696      		adiw r28,6
 2626 0010 0FB6      		in __tmp_reg__,__SREG__
 2627 0012 F894      		cli
 2628 0014 DEBF      		out __SP_H__,r29
 2629 0016 0FBE      		out __SREG__,__tmp_reg__
 2630 0018 CDBF      		out __SP_L__,r28
 2631 001a DF91      		pop r29
 2632 001c CF91      		pop r28
 2633 001e 0895      		ret
 2634               		.cfi_endproc
 2635               	.LFE124:
 2637               		.section	.text.debug_action,"ax",@progbits
 2638               	.global	debug_action
 2640               	debug_action:
 2641               	.LVL223:
 2642               	.LFB125:
 989:tmk_core/common/action.c **** 
 990:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 991:tmk_core/common/action.c ****  *
 992:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 993:tmk_core/common/action.c ****  */
 994:tmk_core/common/action.c **** void debug_action(action_t action)
 995:tmk_core/common/action.c **** {
 2643               		.loc 1 995 1 is_stmt 1 view -0
 2644               		.cfi_startproc
 2645               	/* prologue: function */
 2646               	/* frame size = 0 */
 2647               	/* stack size = 0 */
 2648               	.L__stack_usage = 0
 996:tmk_core/common/action.c ****     switch (action.kind.id) {
 2649               		.loc 1 996 5 view .LVU646
 997:tmk_core/common/action.c ****         case ACT_LMODS:             dprint("ACT_LMODS");             break;
 998:tmk_core/common/action.c ****         case ACT_RMODS:             dprint("ACT_RMODS");             break;
 999:tmk_core/common/action.c ****         case ACT_LMODS_TAP:         dprint("ACT_LMODS_TAP");         break;
1000:tmk_core/common/action.c ****         case ACT_RMODS_TAP:         dprint("ACT_RMODS_TAP");         break;
1001:tmk_core/common/action.c ****         case ACT_USAGE:             dprint("ACT_USAGE");             break;
1002:tmk_core/common/action.c ****         case ACT_MOUSEKEY:          dprint("ACT_MOUSEKEY");          break;
1003:tmk_core/common/action.c ****         case ACT_LAYER:             dprint("ACT_LAYER");             break;
1004:tmk_core/common/action.c ****         case ACT_LAYER_TAP:         dprint("ACT_LAYER_TAP");         break;
1005:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:     dprint("ACT_LAYER_TAP_EXT");     break;
1006:tmk_core/common/action.c ****         case ACT_MACRO:             dprint("ACT_MACRO");             break;
1007:tmk_core/common/action.c ****         case ACT_COMMAND:           dprint("ACT_COMMAND");           break;
1008:tmk_core/common/action.c ****         case ACT_FUNCTION:          dprint("ACT_FUNCTION");          break;
1009:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:        dprint("ACT_SWAP_HANDS");        break;
1010:tmk_core/common/action.c ****         default:                    dprint("UNKNOWN");               break;
1011:tmk_core/common/action.c ****     }
1012:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param>>8, action.kind.param&0xff);
 2650               		.loc 1 1012 71 view .LVU647
 2651               	/* epilogue start */
1013:tmk_core/common/action.c **** }
 2652               		.loc 1 1013 1 is_stmt 0 view .LVU648
 2653 0000 0895      		ret
 2654               		.cfi_endproc
 2655               	.LFE125:
 2657               		.section	.bss.swap_state.4990,"aw",@nobits
 2660               	swap_state.4990:
 2661 0000 0000 0000 		.zero	14
 2661      0000 0000 
 2661      0000 0000 
 2661      0000 
 2662               	.global	disable_action_cache
 2663               		.section	.bss.disable_action_cache,"aw",@nobits
 2666               	disable_action_cache:
 2667 0000 00        		.zero	1
 2668               	.global	swap_held
 2669               		.section	.bss.swap_held,"aw",@nobits
 2672               	swap_held:
 2673 0000 00        		.zero	1
 2674               	.global	swap_hands
 2675               		.section	.bss.swap_hands,"aw",@nobits
 2678               	swap_hands:
 2679 0000 00        		.zero	1
 2680               		.comm	tp_buttons,2,1
 2681               		.text
 2682               	.Letext0:
 2683               		.file 4 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/stdint.h"
 2684               		.file 5 "tmk_core/common/keycode.h"
 2685               		.file 6 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 2686               		.file 7 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 2687               		.file 8 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2688               		.file 9 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 2689               		.file 10 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/stdio.h"
 2690               		.file 11 "tmk_core/common/report.h"
 2691               		.file 12 "tmk_core/common/host.h"
 2692               		.file 13 "tmk_core/common/mousekey.h"
 2693               		.file 14 "tmk_core/common/command.h"
 2694               		.file 15 "tmk_core/common/action_code.h"
 2695               		.file 16 "tmk_core/common/action.h"
 2696               		.file 17 "tmk_core/common/action_layer.h"
 2697               		.file 18 "tmk_core/common/action_util.h"
 2698               		.file 19 "tmk_core/common/debug.h"
 2699               		.file 20 "tmk_core/common/led.h"
 2700               		.file 21 "tmk_core/common/action_macro.h"
 2701               		.file 22 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:4      *ABS*:000000000000003f __SREG__
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:13     .text.process_hand_swap:0000000000000000 process_hand_swap
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2660   .bss.swap_state.4990:0000000000000000 swap_state.4990
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2678   .bss.swap_hands:0000000000000000 swap_hands
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:130    .text.action_exec:0000000000000000 action_exec
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:231    .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:253    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2672   .bss.swap_held:0000000000000000 swap_held
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:299    .text.register_code:0000000000000000 register_code
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:716    .text.unregister_code:0000000000000000 unregister_code
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:884    .text.tap_code:0000000000000000 tap_code
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:918    .text.register_mods:0000000000000000 register_mods
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:947    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:976    .text.process_action:0000000000000000 process_action
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2226   .text.process_record:0000000000000000 process_record
                            *COM*:0000000000000002 tp_buttons
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2336   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2666   .bss.disable_action_cache:0000000000000000 disable_action_cache
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2364   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2403   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2423   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2443   .text.is_tap_action:0000000000000000 is_tap_action
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2531   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2554   .text.debug_event:0000000000000000 debug_event
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2596   .text.debug_record:0000000000000000 debug_record
/var/folders/_c/44sm70yj4mq2k0mvzts6tsbc0000gn/T//cciFTpMM.s:2640   .text.debug_action:0000000000000000 debug_action

UNDEFINED SYMBOLS
hand_swap_config
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
command_proc
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_xor
default_layer_or
layer_and
layer_xor
layer_or
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_clear_bss
