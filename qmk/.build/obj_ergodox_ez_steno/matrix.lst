   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.init_cols,"ax",@progbits
  12               	init_cols:
  13               	.LFB138:
  14               		.file 1 "keyboards/ergodox/ez/matrix.c"
   1:keyboards/ergodox/ez/matrix.c **** /*
   2:keyboards/ergodox/ez/matrix.c **** 
   3:keyboards/ergodox/ez/matrix.c **** Note for ErgoDox EZ customizers: Here be dragons!
   4:keyboards/ergodox/ez/matrix.c **** This is not a file you want to be messing with.
   5:keyboards/ergodox/ez/matrix.c **** All of the interesting stuff for you is under keymaps/ :)
   6:keyboards/ergodox/ez/matrix.c **** Love, Erez
   7:keyboards/ergodox/ez/matrix.c **** 
   8:keyboards/ergodox/ez/matrix.c **** Copyright 2013 Oleg Kostyuk <cub.uanic@gmail.com>
   9:keyboards/ergodox/ez/matrix.c **** 
  10:keyboards/ergodox/ez/matrix.c **** This program is free software: you can redistribute it and/or modify
  11:keyboards/ergodox/ez/matrix.c **** it under the terms of the GNU General Public License as published by
  12:keyboards/ergodox/ez/matrix.c **** the Free Software Foundation, either version 2 of the License, or
  13:keyboards/ergodox/ez/matrix.c **** (at your option) any later version.
  14:keyboards/ergodox/ez/matrix.c **** 
  15:keyboards/ergodox/ez/matrix.c **** This program is distributed in the hope that it will be useful,
  16:keyboards/ergodox/ez/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  17:keyboards/ergodox/ez/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  18:keyboards/ergodox/ez/matrix.c **** GNU General Public License for more details.
  19:keyboards/ergodox/ez/matrix.c **** 
  20:keyboards/ergodox/ez/matrix.c **** You should have received a copy of the GNU General Public License
  21:keyboards/ergodox/ez/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  22:keyboards/ergodox/ez/matrix.c **** */
  23:keyboards/ergodox/ez/matrix.c **** 
  24:keyboards/ergodox/ez/matrix.c **** /*
  25:keyboards/ergodox/ez/matrix.c ****  * scan matrix
  26:keyboards/ergodox/ez/matrix.c ****  */
  27:keyboards/ergodox/ez/matrix.c **** #include <stdint.h>
  28:keyboards/ergodox/ez/matrix.c **** #include <stdbool.h>
  29:keyboards/ergodox/ez/matrix.c **** #include <avr/io.h>
  30:keyboards/ergodox/ez/matrix.c **** #include "wait.h"
  31:keyboards/ergodox/ez/matrix.c **** #include "action_layer.h"
  32:keyboards/ergodox/ez/matrix.c **** #include "print.h"
  33:keyboards/ergodox/ez/matrix.c **** #include "debug.h"
  34:keyboards/ergodox/ez/matrix.c **** #include "util.h"
  35:keyboards/ergodox/ez/matrix.c **** #include "matrix.h"
  36:keyboards/ergodox/ez/matrix.c **** #include "ez.h"
  37:keyboards/ergodox/ez/matrix.c **** #include "i2cmaster.h"
  38:keyboards/ergodox/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
  39:keyboards/ergodox/ez/matrix.c **** #include  "timer.h"
  40:keyboards/ergodox/ez/matrix.c **** #endif
  41:keyboards/ergodox/ez/matrix.c **** 
  42:keyboards/ergodox/ez/matrix.c **** /*
  43:keyboards/ergodox/ez/matrix.c ****  * This constant define not debouncing time in msecs, but amount of matrix
  44:keyboards/ergodox/ez/matrix.c ****  * scan loops which should be made to get stable debounced results.
  45:keyboards/ergodox/ez/matrix.c ****  *
  46:keyboards/ergodox/ez/matrix.c ****  * On Ergodox matrix scan rate is relatively low, because of slow I2C.
  47:keyboards/ergodox/ez/matrix.c ****  * Now it's only 317 scans/second, or about 3.15 msec/scan.
  48:keyboards/ergodox/ez/matrix.c ****  * According to Cherry specs, debouncing time is 5 msec.
  49:keyboards/ergodox/ez/matrix.c ****  *
  50:keyboards/ergodox/ez/matrix.c ****  * And so, there is no sense to have DEBOUNCE higher than 2.
  51:keyboards/ergodox/ez/matrix.c ****  */
  52:keyboards/ergodox/ez/matrix.c **** 
  53:keyboards/ergodox/ez/matrix.c **** #ifndef DEBOUNCE
  54:keyboards/ergodox/ez/matrix.c **** #   define DEBOUNCE	5
  55:keyboards/ergodox/ez/matrix.c **** #endif
  56:keyboards/ergodox/ez/matrix.c **** static uint8_t debouncing = DEBOUNCE;
  57:keyboards/ergodox/ez/matrix.c **** 
  58:keyboards/ergodox/ez/matrix.c **** /* matrix state(1:on, 0:off) */
  59:keyboards/ergodox/ez/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  60:keyboards/ergodox/ez/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  61:keyboards/ergodox/ez/matrix.c **** 
  62:keyboards/ergodox/ez/matrix.c **** static matrix_row_t read_cols(uint8_t row);
  63:keyboards/ergodox/ez/matrix.c **** static void init_cols(void);
  64:keyboards/ergodox/ez/matrix.c **** static void unselect_rows(void);
  65:keyboards/ergodox/ez/matrix.c **** static void select_row(uint8_t row);
  66:keyboards/ergodox/ez/matrix.c **** 
  67:keyboards/ergodox/ez/matrix.c **** static uint8_t mcp23018_reset_loop;
  68:keyboards/ergodox/ez/matrix.c **** 
  69:keyboards/ergodox/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
  70:keyboards/ergodox/ez/matrix.c **** uint32_t matrix_timer;
  71:keyboards/ergodox/ez/matrix.c **** uint32_t matrix_scan_count;
  72:keyboards/ergodox/ez/matrix.c **** #endif
  73:keyboards/ergodox/ez/matrix.c **** 
  74:keyboards/ergodox/ez/matrix.c **** 
  75:keyboards/ergodox/ez/matrix.c **** __attribute__ ((weak))
  76:keyboards/ergodox/ez/matrix.c **** void matrix_init_user(void) {}
  77:keyboards/ergodox/ez/matrix.c **** 
  78:keyboards/ergodox/ez/matrix.c **** __attribute__ ((weak))
  79:keyboards/ergodox/ez/matrix.c **** void matrix_scan_user(void) {}
  80:keyboards/ergodox/ez/matrix.c **** 
  81:keyboards/ergodox/ez/matrix.c **** __attribute__ ((weak))
  82:keyboards/ergodox/ez/matrix.c **** void matrix_init_kb(void) {
  83:keyboards/ergodox/ez/matrix.c ****   matrix_init_user();
  84:keyboards/ergodox/ez/matrix.c **** }
  85:keyboards/ergodox/ez/matrix.c **** 
  86:keyboards/ergodox/ez/matrix.c **** __attribute__ ((weak))
  87:keyboards/ergodox/ez/matrix.c **** void matrix_scan_kb(void) {
  88:keyboards/ergodox/ez/matrix.c ****   matrix_scan_user();
  89:keyboards/ergodox/ez/matrix.c **** }
  90:keyboards/ergodox/ez/matrix.c **** 
  91:keyboards/ergodox/ez/matrix.c **** inline
  92:keyboards/ergodox/ez/matrix.c **** uint8_t matrix_rows(void)
  93:keyboards/ergodox/ez/matrix.c **** {
  94:keyboards/ergodox/ez/matrix.c ****     return MATRIX_ROWS;
  95:keyboards/ergodox/ez/matrix.c **** }
  96:keyboards/ergodox/ez/matrix.c **** 
  97:keyboards/ergodox/ez/matrix.c **** inline
  98:keyboards/ergodox/ez/matrix.c **** uint8_t matrix_cols(void)
  99:keyboards/ergodox/ez/matrix.c **** {
 100:keyboards/ergodox/ez/matrix.c ****     return MATRIX_COLS;
 101:keyboards/ergodox/ez/matrix.c **** }
 102:keyboards/ergodox/ez/matrix.c **** 
 103:keyboards/ergodox/ez/matrix.c **** void matrix_init(void)
 104:keyboards/ergodox/ez/matrix.c **** {
 105:keyboards/ergodox/ez/matrix.c ****     // initialize row and col
 106:keyboards/ergodox/ez/matrix.c **** 
 107:keyboards/ergodox/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 108:keyboards/ergodox/ez/matrix.c **** 
 109:keyboards/ergodox/ez/matrix.c **** 
 110:keyboards/ergodox/ez/matrix.c ****     unselect_rows();
 111:keyboards/ergodox/ez/matrix.c ****     init_cols();
 112:keyboards/ergodox/ez/matrix.c **** 
 113:keyboards/ergodox/ez/matrix.c ****     // initialize matrix state: all keys off
 114:keyboards/ergodox/ez/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 115:keyboards/ergodox/ez/matrix.c ****         matrix[i] = 0;
 116:keyboards/ergodox/ez/matrix.c ****         matrix_debouncing[i] = 0;
 117:keyboards/ergodox/ez/matrix.c ****     }
 118:keyboards/ergodox/ez/matrix.c **** 
 119:keyboards/ergodox/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 120:keyboards/ergodox/ez/matrix.c ****     matrix_timer = timer_read32();
 121:keyboards/ergodox/ez/matrix.c ****     matrix_scan_count = 0;
 122:keyboards/ergodox/ez/matrix.c **** #endif
 123:keyboards/ergodox/ez/matrix.c **** 
 124:keyboards/ergodox/ez/matrix.c ****     matrix_init_kb();
 125:keyboards/ergodox/ez/matrix.c **** 
 126:keyboards/ergodox/ez/matrix.c **** }
 127:keyboards/ergodox/ez/matrix.c **** 
 128:keyboards/ergodox/ez/matrix.c **** void matrix_power_up(void) {
 129:keyboards/ergodox/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 130:keyboards/ergodox/ez/matrix.c **** 
 131:keyboards/ergodox/ez/matrix.c ****     unselect_rows();
 132:keyboards/ergodox/ez/matrix.c ****     init_cols();
 133:keyboards/ergodox/ez/matrix.c **** 
 134:keyboards/ergodox/ez/matrix.c ****     // initialize matrix state: all keys off
 135:keyboards/ergodox/ez/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 136:keyboards/ergodox/ez/matrix.c ****         matrix[i] = 0;
 137:keyboards/ergodox/ez/matrix.c ****         matrix_debouncing[i] = 0;
 138:keyboards/ergodox/ez/matrix.c ****     }
 139:keyboards/ergodox/ez/matrix.c **** 
 140:keyboards/ergodox/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 141:keyboards/ergodox/ez/matrix.c ****     matrix_timer = timer_read32();
 142:keyboards/ergodox/ez/matrix.c ****     matrix_scan_count = 0;
 143:keyboards/ergodox/ez/matrix.c **** #endif
 144:keyboards/ergodox/ez/matrix.c **** 
 145:keyboards/ergodox/ez/matrix.c **** }
 146:keyboards/ergodox/ez/matrix.c **** 
 147:keyboards/ergodox/ez/matrix.c **** uint8_t matrix_scan(void)
 148:keyboards/ergodox/ez/matrix.c **** {
 149:keyboards/ergodox/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 150:keyboards/ergodox/ez/matrix.c ****         if (++mcp23018_reset_loop == 0) {
 151:keyboards/ergodox/ez/matrix.c ****             // since mcp23018_reset_loop is 8 bit - we'll try to reset once in 255 matrix scans
 152:keyboards/ergodox/ez/matrix.c ****             // this will be approx bit more frequent than once per second
 153:keyboards/ergodox/ez/matrix.c ****             print("trying to reset mcp23018\n");
 154:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = init_mcp23018();
 155:keyboards/ergodox/ez/matrix.c ****             if (mcp23018_status) {
 156:keyboards/ergodox/ez/matrix.c ****                 print("left side not responding\n");
 157:keyboards/ergodox/ez/matrix.c ****             } else {
 158:keyboards/ergodox/ez/matrix.c ****                 print("left side attached\n");
 159:keyboards/ergodox/ez/matrix.c ****                 ergodox_blink_all_leds();
 160:keyboards/ergodox/ez/matrix.c ****             }
 161:keyboards/ergodox/ez/matrix.c ****         }
 162:keyboards/ergodox/ez/matrix.c ****     }
 163:keyboards/ergodox/ez/matrix.c **** 
 164:keyboards/ergodox/ez/matrix.c **** #ifdef DEBUG_MATRIX_SCAN_RATE
 165:keyboards/ergodox/ez/matrix.c ****     matrix_scan_count++;
 166:keyboards/ergodox/ez/matrix.c **** 
 167:keyboards/ergodox/ez/matrix.c ****     uint32_t timer_now = timer_read32();
 168:keyboards/ergodox/ez/matrix.c ****     if (TIMER_DIFF_32(timer_now, matrix_timer)>1000) {
 169:keyboards/ergodox/ez/matrix.c ****         print("matrix scan frequency: ");
 170:keyboards/ergodox/ez/matrix.c ****         pdec(matrix_scan_count);
 171:keyboards/ergodox/ez/matrix.c ****         print("\n");
 172:keyboards/ergodox/ez/matrix.c **** 
 173:keyboards/ergodox/ez/matrix.c ****         matrix_timer = timer_now;
 174:keyboards/ergodox/ez/matrix.c ****         matrix_scan_count = 0;
 175:keyboards/ergodox/ez/matrix.c ****     }
 176:keyboards/ergodox/ez/matrix.c **** #endif
 177:keyboards/ergodox/ez/matrix.c **** 
 178:keyboards/ergodox/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 179:keyboards/ergodox/ez/matrix.c ****         select_row(i);
 180:keyboards/ergodox/ez/matrix.c ****         wait_us(30);  // without this wait read unstable value.
 181:keyboards/ergodox/ez/matrix.c ****         matrix_row_t cols = read_cols(i);
 182:keyboards/ergodox/ez/matrix.c ****         if (matrix_debouncing[i] != cols) {
 183:keyboards/ergodox/ez/matrix.c ****             matrix_debouncing[i] = cols;
 184:keyboards/ergodox/ez/matrix.c ****             if (debouncing) {
 185:keyboards/ergodox/ez/matrix.c ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 186:keyboards/ergodox/ez/matrix.c ****             }
 187:keyboards/ergodox/ez/matrix.c ****             debouncing = DEBOUNCE;
 188:keyboards/ergodox/ez/matrix.c ****         }
 189:keyboards/ergodox/ez/matrix.c ****         unselect_rows();
 190:keyboards/ergodox/ez/matrix.c ****     }
 191:keyboards/ergodox/ez/matrix.c **** 
 192:keyboards/ergodox/ez/matrix.c ****     if (debouncing) {
 193:keyboards/ergodox/ez/matrix.c ****         if (--debouncing) {
 194:keyboards/ergodox/ez/matrix.c ****             wait_us(1);
 195:keyboards/ergodox/ez/matrix.c ****             // this should be wait_ms(1) but has been left as-is at EZ's request
 196:keyboards/ergodox/ez/matrix.c ****         } else {
 197:keyboards/ergodox/ez/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 198:keyboards/ergodox/ez/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 199:keyboards/ergodox/ez/matrix.c ****             }
 200:keyboards/ergodox/ez/matrix.c ****         }
 201:keyboards/ergodox/ez/matrix.c ****     }
 202:keyboards/ergodox/ez/matrix.c **** 
 203:keyboards/ergodox/ez/matrix.c ****     matrix_scan_quantum();
 204:keyboards/ergodox/ez/matrix.c **** 
 205:keyboards/ergodox/ez/matrix.c ****     return 1;
 206:keyboards/ergodox/ez/matrix.c **** }
 207:keyboards/ergodox/ez/matrix.c **** 
 208:keyboards/ergodox/ez/matrix.c **** bool matrix_is_modified(void)
 209:keyboards/ergodox/ez/matrix.c **** {
 210:keyboards/ergodox/ez/matrix.c ****     if (debouncing) return false;
 211:keyboards/ergodox/ez/matrix.c ****     return true;
 212:keyboards/ergodox/ez/matrix.c **** }
 213:keyboards/ergodox/ez/matrix.c **** 
 214:keyboards/ergodox/ez/matrix.c **** inline
 215:keyboards/ergodox/ez/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 216:keyboards/ergodox/ez/matrix.c **** {
 217:keyboards/ergodox/ez/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 218:keyboards/ergodox/ez/matrix.c **** }
 219:keyboards/ergodox/ez/matrix.c **** 
 220:keyboards/ergodox/ez/matrix.c **** inline
 221:keyboards/ergodox/ez/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 222:keyboards/ergodox/ez/matrix.c **** {
 223:keyboards/ergodox/ez/matrix.c ****     return matrix[row];
 224:keyboards/ergodox/ez/matrix.c **** }
 225:keyboards/ergodox/ez/matrix.c **** 
 226:keyboards/ergodox/ez/matrix.c **** void matrix_print(void)
 227:keyboards/ergodox/ez/matrix.c **** {
 228:keyboards/ergodox/ez/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 229:keyboards/ergodox/ez/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 230:keyboards/ergodox/ez/matrix.c ****         phex(row); print(": ");
 231:keyboards/ergodox/ez/matrix.c ****         pbin_reverse16(matrix_get_row(row));
 232:keyboards/ergodox/ez/matrix.c ****         print("\n");
 233:keyboards/ergodox/ez/matrix.c ****     }
 234:keyboards/ergodox/ez/matrix.c **** }
 235:keyboards/ergodox/ez/matrix.c **** 
 236:keyboards/ergodox/ez/matrix.c **** uint8_t matrix_key_count(void)
 237:keyboards/ergodox/ez/matrix.c **** {
 238:keyboards/ergodox/ez/matrix.c ****     uint8_t count = 0;
 239:keyboards/ergodox/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 240:keyboards/ergodox/ez/matrix.c ****         count += bitpop16(matrix[i]);
 241:keyboards/ergodox/ez/matrix.c ****     }
 242:keyboards/ergodox/ez/matrix.c ****     return count;
 243:keyboards/ergodox/ez/matrix.c **** }
 244:keyboards/ergodox/ez/matrix.c **** 
 245:keyboards/ergodox/ez/matrix.c **** /* Column pin configuration
 246:keyboards/ergodox/ez/matrix.c ****  *
 247:keyboards/ergodox/ez/matrix.c ****  * Teensy
 248:keyboards/ergodox/ez/matrix.c ****  * col: 0   1   2   3   4   5
 249:keyboards/ergodox/ez/matrix.c ****  * pin: F0  F1  F4  F5  F6  F7
 250:keyboards/ergodox/ez/matrix.c ****  *
 251:keyboards/ergodox/ez/matrix.c ****  * MCP23018
 252:keyboards/ergodox/ez/matrix.c ****  * col: 0   1   2   3   4   5
 253:keyboards/ergodox/ez/matrix.c ****  * pin: B5  B4  B3  B2  B1  B0
 254:keyboards/ergodox/ez/matrix.c ****  */
 255:keyboards/ergodox/ez/matrix.c **** static void  init_cols(void)
 256:keyboards/ergodox/ez/matrix.c **** {
  15               		.loc 1 256 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 257:keyboards/ergodox/ez/matrix.c ****     // init on mcp23018
 258:keyboards/ergodox/ez/matrix.c ****     // not needed, already done as part of init_mcp23018()
 259:keyboards/ergodox/ez/matrix.c **** 
 260:keyboards/ergodox/ez/matrix.c ****     // init on teensy
 261:keyboards/ergodox/ez/matrix.c ****     // Input with pull-up(DDR:0, PORT:1)
 262:keyboards/ergodox/ez/matrix.c ****     DDRF  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
  21               		.loc 1 262 0
  22 0000 80B3      		in r24,0x10
  23 0002 8C70      		andi r24,lo8(12)
  24 0004 80BB      		out 0x10,r24
 263:keyboards/ergodox/ez/matrix.c ****     PORTF |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
  25               		.loc 1 263 0
  26 0006 81B3      		in r24,0x11
  27 0008 836F      		ori r24,lo8(-13)
  28 000a 81BB      		out 0x11,r24
  29 000c 0895      		ret
  30               		.cfi_endproc
  31               	.LFE138:
  33               		.section	.text.unselect_rows,"ax",@progbits
  35               	unselect_rows:
  36               	.LFB140:
 264:keyboards/ergodox/ez/matrix.c **** }
 265:keyboards/ergodox/ez/matrix.c **** 
 266:keyboards/ergodox/ez/matrix.c **** static matrix_row_t read_cols(uint8_t row)
 267:keyboards/ergodox/ez/matrix.c **** {
 268:keyboards/ergodox/ez/matrix.c ****     if (row < 7) {
 269:keyboards/ergodox/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 270:keyboards/ergodox/ez/matrix.c ****             return 0;
 271:keyboards/ergodox/ez/matrix.c ****         } else {
 272:keyboards/ergodox/ez/matrix.c ****             uint8_t data = 0;
 273:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
 274:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 275:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 276:keyboards/ergodox/ez/matrix.c ****             data = i2c_readNak();
 277:keyboards/ergodox/ez/matrix.c ****             data = ~data;
 278:keyboards/ergodox/ez/matrix.c ****         out:
 279:keyboards/ergodox/ez/matrix.c ****             i2c_stop();
 280:keyboards/ergodox/ez/matrix.c ****             return data;
 281:keyboards/ergodox/ez/matrix.c ****         }
 282:keyboards/ergodox/ez/matrix.c ****     } else {
 283:keyboards/ergodox/ez/matrix.c ****         // read from teensy
 284:keyboards/ergodox/ez/matrix.c ****         return
 285:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 286:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 287:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<4) ? 0 : (1<<2)) |
 288:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<5) ? 0 : (1<<3)) |
 289:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 290:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<7) ? 0 : (1<<5)) ;
 291:keyboards/ergodox/ez/matrix.c ****     }
 292:keyboards/ergodox/ez/matrix.c **** }
 293:keyboards/ergodox/ez/matrix.c **** 
 294:keyboards/ergodox/ez/matrix.c **** /* Row pin configuration
 295:keyboards/ergodox/ez/matrix.c ****  *
 296:keyboards/ergodox/ez/matrix.c ****  * Teensy
 297:keyboards/ergodox/ez/matrix.c ****  * row: 7   8   9   10  11  12  13
 298:keyboards/ergodox/ez/matrix.c ****  * pin: B0  B1  B2  B3  D2  D3  C6
 299:keyboards/ergodox/ez/matrix.c ****  *
 300:keyboards/ergodox/ez/matrix.c ****  * MCP23018
 301:keyboards/ergodox/ez/matrix.c ****  * row: 0   1   2   3   4   5   6
 302:keyboards/ergodox/ez/matrix.c ****  * pin: A0  A1  A2  A3  A4  A5  A6
 303:keyboards/ergodox/ez/matrix.c ****  */
 304:keyboards/ergodox/ez/matrix.c **** static void unselect_rows(void)
 305:keyboards/ergodox/ez/matrix.c **** {
  37               		.loc 1 305 0
  38               		.cfi_startproc
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
 306:keyboards/ergodox/ez/matrix.c ****     // unselect on mcp23018
 307:keyboards/ergodox/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
  43               		.loc 1 307 0
  44 0000 8091 0000 		lds r24,mcp23018_status
  45 0004 8111      		cpse r24,__zero_reg__
  46 0006 00C0      		rjmp .L3
 308:keyboards/ergodox/ez/matrix.c ****         // do nothing
 309:keyboards/ergodox/ez/matrix.c ****     } else {
 310:keyboards/ergodox/ez/matrix.c ****         // set all rows hi-Z : 1
 311:keyboards/ergodox/ez/matrix.c ****         mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
  47               		.loc 1 311 0
  48 0008 80E4      		ldi r24,lo8(64)
  49 000a 0E94 0000 		call i2c_start
  50               	.LVL0:
  51 000e 8093 0000 		sts mcp23018_status,r24
  52 0012 8111      		cpse r24,__zero_reg__
  53 0014 00C0      		rjmp .L5
 312:keyboards/ergodox/ez/matrix.c ****         mcp23018_status = i2c_write(GPIOA);             if (mcp23018_status) goto out;
  54               		.loc 1 312 0
  55 0016 82E1      		ldi r24,lo8(18)
  56 0018 0E94 0000 		call i2c_write
  57               	.LVL1:
  58 001c 8093 0000 		sts mcp23018_status,r24
  59 0020 8111      		cpse r24,__zero_reg__
  60 0022 00C0      		rjmp .L5
 313:keyboards/ergodox/ez/matrix.c ****         mcp23018_status = i2c_write( 0xFF
  61               		.loc 1 313 0
  62 0024 8FEF      		ldi r24,lo8(-1)
  63 0026 0E94 0000 		call i2c_write
  64               	.LVL2:
  65 002a 8093 0000 		sts mcp23018_status,r24
  66               	.L5:
 314:keyboards/ergodox/ez/matrix.c ****                               & ~(0<<7)
 315:keyboards/ergodox/ez/matrix.c ****                           );                            if (mcp23018_status) goto out;
 316:keyboards/ergodox/ez/matrix.c ****     out:
 317:keyboards/ergodox/ez/matrix.c ****         i2c_stop();
  67               		.loc 1 317 0
  68 002e 0E94 0000 		call i2c_stop
  69               	.LVL3:
  70               	.L3:
 318:keyboards/ergodox/ez/matrix.c ****     }
 319:keyboards/ergodox/ez/matrix.c **** 
 320:keyboards/ergodox/ez/matrix.c ****     // unselect on teensy
 321:keyboards/ergodox/ez/matrix.c ****     // Hi-Z(DDR:0, PORT:0) to unselect
 322:keyboards/ergodox/ez/matrix.c ****     DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
  71               		.loc 1 322 0
  72 0032 84B1      		in r24,0x4
  73 0034 807F      		andi r24,lo8(-16)
  74 0036 84B9      		out 0x4,r24
 323:keyboards/ergodox/ez/matrix.c ****     PORTB &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
  75               		.loc 1 323 0
  76 0038 85B1      		in r24,0x5
  77 003a 807F      		andi r24,lo8(-16)
  78 003c 85B9      		out 0x5,r24
 324:keyboards/ergodox/ez/matrix.c ****     DDRD  &= ~(1<<2 | 1<<3);
  79               		.loc 1 324 0
  80 003e 8AB1      		in r24,0xa
  81 0040 837F      		andi r24,lo8(-13)
  82 0042 8AB9      		out 0xa,r24
 325:keyboards/ergodox/ez/matrix.c ****     PORTD &= ~(1<<2 | 1<<3);
  83               		.loc 1 325 0
  84 0044 8BB1      		in r24,0xb
  85 0046 837F      		andi r24,lo8(-13)
  86 0048 8BB9      		out 0xb,r24
 326:keyboards/ergodox/ez/matrix.c ****     DDRC  &= ~(1<<6);
  87               		.loc 1 326 0
  88 004a 3E98      		cbi 0x7,6
 327:keyboards/ergodox/ez/matrix.c ****     PORTC &= ~(1<<6);
  89               		.loc 1 327 0
  90 004c 4698      		cbi 0x8,6
  91 004e 0895      		ret
  92               		.cfi_endproc
  93               	.LFE140:
  95               		.section	.text.matrix_init_user,"ax",@progbits
  96               		.weak	matrix_init_user
  98               	matrix_init_user:
  99               	.LFB124:
  76:keyboards/ergodox/ez/matrix.c **** 
 100               		.loc 1 76 0
 101               		.cfi_startproc
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 0 */
 105               	.L__stack_usage = 0
 106 0000 0895      		ret
 107               		.cfi_endproc
 108               	.LFE124:
 110               		.section	.text.matrix_scan_user,"ax",@progbits
 111               		.weak	matrix_scan_user
 113               	matrix_scan_user:
 114               	.LFB125:
  79:keyboards/ergodox/ez/matrix.c **** 
 115               		.loc 1 79 0
 116               		.cfi_startproc
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 121 0000 0895      		ret
 122               		.cfi_endproc
 123               	.LFE125:
 125               		.section	.text.matrix_init_kb,"ax",@progbits
 126               		.weak	matrix_init_kb
 128               	matrix_init_kb:
 129               	.LFB126:
  82:keyboards/ergodox/ez/matrix.c ****   matrix_init_user();
 130               		.loc 1 82 0
 131               		.cfi_startproc
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 0 */
 135               	.L__stack_usage = 0
  83:keyboards/ergodox/ez/matrix.c **** }
 136               		.loc 1 83 0
 137 0000 0C94 0000 		jmp matrix_init_user
 138               	.LVL4:
 139               		.cfi_endproc
 140               	.LFE126:
 142               		.section	.text.matrix_scan_kb,"ax",@progbits
 143               		.weak	matrix_scan_kb
 145               	matrix_scan_kb:
 146               	.LFB127:
  87:keyboards/ergodox/ez/matrix.c ****   matrix_scan_user();
 147               		.loc 1 87 0
 148               		.cfi_startproc
 149               	/* prologue: function */
 150               	/* frame size = 0 */
 151               	/* stack size = 0 */
 152               	.L__stack_usage = 0
  88:keyboards/ergodox/ez/matrix.c **** }
 153               		.loc 1 88 0
 154 0000 0C94 0000 		jmp matrix_scan_user
 155               	.LVL5:
 156               		.cfi_endproc
 157               	.LFE127:
 159               		.section	.text.matrix_rows,"ax",@progbits
 160               	.global	matrix_rows
 162               	matrix_rows:
 163               	.LFB128:
  93:keyboards/ergodox/ez/matrix.c ****     return MATRIX_ROWS;
 164               		.loc 1 93 0
 165               		.cfi_startproc
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
  95:keyboards/ergodox/ez/matrix.c **** 
 170               		.loc 1 95 0
 171 0000 8EE0      		ldi r24,lo8(14)
 172 0002 0895      		ret
 173               		.cfi_endproc
 174               	.LFE128:
 176               		.section	.text.matrix_cols,"ax",@progbits
 177               	.global	matrix_cols
 179               	matrix_cols:
 180               	.LFB129:
  99:keyboards/ergodox/ez/matrix.c ****     return MATRIX_COLS;
 181               		.loc 1 99 0
 182               		.cfi_startproc
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
 101:keyboards/ergodox/ez/matrix.c **** 
 187               		.loc 1 101 0
 188 0000 86E0      		ldi r24,lo8(6)
 189 0002 0895      		ret
 190               		.cfi_endproc
 191               	.LFE129:
 193               		.section	.text.matrix_init,"ax",@progbits
 194               	.global	matrix_init
 196               	matrix_init:
 197               	.LFB130:
 104:keyboards/ergodox/ez/matrix.c ****     // initialize row and col
 198               		.loc 1 104 0
 199               		.cfi_startproc
 200               	/* prologue: function */
 201               	/* frame size = 0 */
 202               	/* stack size = 0 */
 203               	.L__stack_usage = 0
 107:keyboards/ergodox/ez/matrix.c **** 
 204               		.loc 1 107 0
 205 0000 0E94 0000 		call init_mcp23018
 206               	.LVL6:
 207 0004 8093 0000 		sts mcp23018_status,r24
 110:keyboards/ergodox/ez/matrix.c ****     init_cols();
 208               		.loc 1 110 0
 209 0008 0E94 0000 		call unselect_rows
 210               	.LVL7:
 111:keyboards/ergodox/ez/matrix.c **** 
 211               		.loc 1 111 0
 212 000c 0E94 0000 		call init_cols
 213               	.LVL8:
 214 0010 A0E0      		ldi r26,lo8(matrix_debouncing)
 215 0012 B0E0      		ldi r27,hi8(matrix_debouncing)
 216 0014 E0E0      		ldi r30,lo8(matrix)
 217 0016 F0E0      		ldi r31,hi8(matrix)
 218 0018 8EE0      		ldi r24,lo8(14)
 219 001a 8E0F      		add r24,r30
 220               	.LVL9:
 221               	.L15:
 222               	.LBB9:
 115:keyboards/ergodox/ez/matrix.c ****         matrix_debouncing[i] = 0;
 223               		.loc 1 115 0 discriminator 3
 224 001c 1192      		st Z+,__zero_reg__
 225               	.LVL10:
 116:keyboards/ergodox/ez/matrix.c ****     }
 226               		.loc 1 116 0 discriminator 3
 227 001e 1D92      		st X+,__zero_reg__
 228               	.LVL11:
 114:keyboards/ergodox/ez/matrix.c ****         matrix[i] = 0;
 229               		.loc 1 114 0 discriminator 3
 230 0020 8E13      		cpse r24,r30
 231 0022 00C0      		rjmp .L15
 232               	.LBE9:
 124:keyboards/ergodox/ez/matrix.c **** 
 233               		.loc 1 124 0
 234 0024 0C94 0000 		jmp matrix_init_kb
 235               	.LVL12:
 236               		.cfi_endproc
 237               	.LFE130:
 239               		.section	.text.matrix_power_up,"ax",@progbits
 240               	.global	matrix_power_up
 242               	matrix_power_up:
 243               	.LFB131:
 128:keyboards/ergodox/ez/matrix.c ****     mcp23018_status = init_mcp23018();
 244               		.loc 1 128 0
 245               		.cfi_startproc
 246               	/* prologue: function */
 247               	/* frame size = 0 */
 248               	/* stack size = 0 */
 249               	.L__stack_usage = 0
 129:keyboards/ergodox/ez/matrix.c **** 
 250               		.loc 1 129 0
 251 0000 0E94 0000 		call init_mcp23018
 252               	.LVL13:
 253 0004 8093 0000 		sts mcp23018_status,r24
 131:keyboards/ergodox/ez/matrix.c ****     init_cols();
 254               		.loc 1 131 0
 255 0008 0E94 0000 		call unselect_rows
 256               	.LVL14:
 132:keyboards/ergodox/ez/matrix.c **** 
 257               		.loc 1 132 0
 258 000c 0E94 0000 		call init_cols
 259               	.LVL15:
 260 0010 A0E0      		ldi r26,lo8(matrix_debouncing)
 261 0012 B0E0      		ldi r27,hi8(matrix_debouncing)
 262 0014 E0E0      		ldi r30,lo8(matrix)
 263 0016 F0E0      		ldi r31,hi8(matrix)
 264 0018 8EE0      		ldi r24,lo8(14)
 265 001a 8E0F      		add r24,r30
 266               	.LVL16:
 267               	.L18:
 268               	.LBB10:
 136:keyboards/ergodox/ez/matrix.c ****         matrix_debouncing[i] = 0;
 269               		.loc 1 136 0 discriminator 3
 270 001c 1192      		st Z+,__zero_reg__
 271               	.LVL17:
 137:keyboards/ergodox/ez/matrix.c ****     }
 272               		.loc 1 137 0 discriminator 3
 273 001e 1D92      		st X+,__zero_reg__
 274               	.LVL18:
 135:keyboards/ergodox/ez/matrix.c ****         matrix[i] = 0;
 275               		.loc 1 135 0 discriminator 3
 276 0020 8E13      		cpse r24,r30
 277 0022 00C0      		rjmp .L18
 278               	/* epilogue start */
 279               	.LBE10:
 145:keyboards/ergodox/ez/matrix.c **** 
 280               		.loc 1 145 0
 281 0024 0895      		ret
 282               		.cfi_endproc
 283               	.LFE131:
 285               		.section	.text.matrix_scan,"ax",@progbits
 286               	.global	matrix_scan
 288               	matrix_scan:
 289               	.LFB132:
 148:keyboards/ergodox/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 290               		.loc 1 148 0
 291               		.cfi_startproc
 292 0000 BF92      		push r11
 293               	.LCFI0:
 294               		.cfi_def_cfa_offset 3
 295               		.cfi_offset 11, -2
 296 0002 CF92      		push r12
 297               	.LCFI1:
 298               		.cfi_def_cfa_offset 4
 299               		.cfi_offset 12, -3
 300 0004 DF92      		push r13
 301               	.LCFI2:
 302               		.cfi_def_cfa_offset 5
 303               		.cfi_offset 13, -4
 304 0006 EF92      		push r14
 305               	.LCFI3:
 306               		.cfi_def_cfa_offset 6
 307               		.cfi_offset 14, -5
 308 0008 FF92      		push r15
 309               	.LCFI4:
 310               		.cfi_def_cfa_offset 7
 311               		.cfi_offset 15, -6
 312 000a 0F93      		push r16
 313               	.LCFI5:
 314               		.cfi_def_cfa_offset 8
 315               		.cfi_offset 16, -7
 316 000c 1F93      		push r17
 317               	.LCFI6:
 318               		.cfi_def_cfa_offset 9
 319               		.cfi_offset 17, -8
 320 000e CF93      		push r28
 321               	.LCFI7:
 322               		.cfi_def_cfa_offset 10
 323               		.cfi_offset 28, -9
 324 0010 DF93      		push r29
 325               	.LCFI8:
 326               		.cfi_def_cfa_offset 11
 327               		.cfi_offset 29, -10
 328               	/* prologue: function */
 329               	/* frame size = 0 */
 330               	/* stack size = 9 */
 331               	.L__stack_usage = 9
 149:keyboards/ergodox/ez/matrix.c ****         if (++mcp23018_reset_loop == 0) {
 332               		.loc 1 149 0
 333 0012 8091 0000 		lds r24,mcp23018_status
 334 0016 8823      		tst r24
 335 0018 01F0      		breq .L22
 150:keyboards/ergodox/ez/matrix.c ****             // since mcp23018_reset_loop is 8 bit - we'll try to reset once in 255 matrix scans
 336               		.loc 1 150 0
 337 001a 8091 0000 		lds r24,mcp23018_reset_loop
 338 001e 8F5F      		subi r24,lo8(-(1))
 339 0020 8093 0000 		sts mcp23018_reset_loop,r24
 340 0024 8111      		cpse r24,__zero_reg__
 341 0026 00C0      		rjmp .L22
 154:keyboards/ergodox/ez/matrix.c ****             if (mcp23018_status) {
 342               		.loc 1 154 0
 343 0028 0E94 0000 		call init_mcp23018
 344               	.LVL19:
 345 002c 8093 0000 		sts mcp23018_status,r24
 155:keyboards/ergodox/ez/matrix.c ****                 print("left side not responding\n");
 346               		.loc 1 155 0
 347 0030 8111      		cpse r24,__zero_reg__
 348 0032 00C0      		rjmp .L22
 159:keyboards/ergodox/ez/matrix.c ****             }
 349               		.loc 1 159 0
 350 0034 0E94 0000 		call ergodox_blink_all_leds
 351               	.LVL20:
 352               	.L22:
 148:keyboards/ergodox/ez/matrix.c ****     if (mcp23018_status) { // if there was an error
 353               		.loc 1 148 0 discriminator 1
 354 0038 00E0      		ldi r16,lo8(matrix_debouncing)
 355 003a 10E0      		ldi r17,hi8(matrix_debouncing)
 356 003c C0E0      		ldi r28,0
 357 003e D0E0      		ldi r29,0
 358               	.LBB23:
 359               	.LBB24:
 360               	.LBB25:
 361               	.LBB26:
 328:keyboards/ergodox/ez/matrix.c **** }
 329:keyboards/ergodox/ez/matrix.c **** 
 330:keyboards/ergodox/ez/matrix.c **** static void select_row(uint8_t row)
 331:keyboards/ergodox/ez/matrix.c **** {
 332:keyboards/ergodox/ez/matrix.c ****     if (row < 7) {
 333:keyboards/ergodox/ez/matrix.c ****         // select on mcp23018
 334:keyboards/ergodox/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 335:keyboards/ergodox/ez/matrix.c ****             // do nothing
 336:keyboards/ergodox/ez/matrix.c ****         } else {
 337:keyboards/ergodox/ez/matrix.c ****             // set active row low  : 0
 338:keyboards/ergodox/ez/matrix.c ****             // set other rows hi-Z : 1
 339:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);        if (mcp23018_status) goto out;
 340:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 341:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write( 0xFF & ~(1<<row)
 362               		.loc 1 341 0 discriminator 1
 363 0040 EE24      		clr r14
 364 0042 E394      		inc r14
 365 0044 F12C      		mov r15,__zero_reg__
 366 0046 DD24      		clr r13
 367 0048 D394      		inc r13
 368               	.LBE26:
 369               	.LBE25:
 187:keyboards/ergodox/ez/matrix.c ****         }
 370               		.loc 1 187 0 discriminator 1
 371 004a 95E0      		ldi r25,lo8(5)
 372 004c C92E      		mov r12,r25
 373               	.LVL21:
 374               	.L48:
 375               	.LBB28:
 376               	.LBB27:
 332:keyboards/ergodox/ez/matrix.c ****         // select on mcp23018
 377               		.loc 1 332 0
 378 004e C730      		cpi r28,7
 379 0050 D105      		cpc r29,__zero_reg__
 380 0052 00F4      		brsh .L24
 334:keyboards/ergodox/ez/matrix.c ****             // do nothing
 381               		.loc 1 334 0
 382 0054 8091 0000 		lds r24,mcp23018_status
 383 0058 8111      		cpse r24,__zero_reg__
 384 005a 00C0      		rjmp .L25
 339:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 385               		.loc 1 339 0
 386 005c 80E4      		ldi r24,lo8(64)
 387 005e 0E94 0000 		call i2c_start
 388               	.LVL22:
 389 0062 8093 0000 		sts mcp23018_status,r24
 390 0066 8111      		cpse r24,__zero_reg__
 391 0068 00C0      		rjmp .L27
 340:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write( 0xFF & ~(1<<row)
 392               		.loc 1 340 0
 393 006a 82E1      		ldi r24,lo8(18)
 394 006c 0E94 0000 		call i2c_write
 395               	.LVL23:
 396 0070 8093 0000 		sts mcp23018_status,r24
 397 0074 8111      		cpse r24,__zero_reg__
 398 0076 00C0      		rjmp .L27
 399               		.loc 1 341 0
 400 0078 C701      		movw r24,r14
 401 007a 0C2E      		mov r0,r28
 402 007c 00C0      		rjmp 2f
 403               		1:
 404 007e 880F      		lsl r24
 405               		2:
 406 0080 0A94      		dec r0
 407 0082 02F4      		brpl 1b
 408 0084 8095      		com r24
 409 0086 0E94 0000 		call i2c_write
 410               	.LVL24:
 411 008a 8093 0000 		sts mcp23018_status,r24
 412               	.L27:
 342:keyboards/ergodox/ez/matrix.c ****                                   & ~(0<<7)
 343:keyboards/ergodox/ez/matrix.c ****                               );                                if (mcp23018_status) goto out;
 344:keyboards/ergodox/ez/matrix.c ****         out:
 345:keyboards/ergodox/ez/matrix.c ****             i2c_stop();
 413               		.loc 1 345 0
 414 008e 0E94 0000 		call i2c_stop
 415               	.LVL25:
 416 0092 00C0      		rjmp .L25
 417               	.L24:
 346:keyboards/ergodox/ez/matrix.c ****         }
 347:keyboards/ergodox/ez/matrix.c ****     } else {
 348:keyboards/ergodox/ez/matrix.c ****         // select on teensy
 349:keyboards/ergodox/ez/matrix.c ****         // Output low(DDR:1, PORT:0) to select
 350:keyboards/ergodox/ez/matrix.c ****         switch (row) {
 418               		.loc 1 350 0
 419 0094 CA30      		cpi r28,lo8(10)
 420 0096 01F0      		breq .L30
 421 0098 00F4      		brsh .L31
 422 009a C830      		cpi r28,lo8(8)
 423 009c 01F0      		breq .L32
 424 009e C930      		cpi r28,lo8(9)
 425 00a0 01F0      		breq .L33
 426 00a2 00C0      		rjmp .L29
 427               	.L31:
 428 00a4 CC30      		cpi r28,lo8(12)
 429 00a6 01F0      		breq .L34
 430 00a8 00F0      		brlo .L35
 431 00aa CD30      		cpi r28,lo8(13)
 432 00ac 01F0      		breq .L36
 433               	.L29:
 351:keyboards/ergodox/ez/matrix.c ****             case 7:
 352:keyboards/ergodox/ez/matrix.c ****                 DDRB  |= (1<<0);
 434               		.loc 1 352 0
 435 00ae 209A      		sbi 0x4,0
 353:keyboards/ergodox/ez/matrix.c ****                 PORTB &= ~(1<<0);
 436               		.loc 1 353 0
 437 00b0 2898      		cbi 0x5,0
 438 00b2 00C0      		rjmp .L25
 439               	.L32:
 354:keyboards/ergodox/ez/matrix.c ****                 break;
 355:keyboards/ergodox/ez/matrix.c ****             case 8:
 356:keyboards/ergodox/ez/matrix.c ****                 DDRB  |= (1<<1);
 440               		.loc 1 356 0
 441 00b4 219A      		sbi 0x4,1
 357:keyboards/ergodox/ez/matrix.c ****                 PORTB &= ~(1<<1);
 442               		.loc 1 357 0
 443 00b6 2998      		cbi 0x5,1
 444 00b8 00C0      		rjmp .L25
 445               	.L33:
 358:keyboards/ergodox/ez/matrix.c ****                 break;
 359:keyboards/ergodox/ez/matrix.c ****             case 9:
 360:keyboards/ergodox/ez/matrix.c ****                 DDRB  |= (1<<2);
 446               		.loc 1 360 0
 447 00ba 229A      		sbi 0x4,2
 361:keyboards/ergodox/ez/matrix.c ****                 PORTB &= ~(1<<2);
 448               		.loc 1 361 0
 449 00bc 2A98      		cbi 0x5,2
 450 00be 00C0      		rjmp .L25
 451               	.L30:
 362:keyboards/ergodox/ez/matrix.c ****                 break;
 363:keyboards/ergodox/ez/matrix.c ****             case 10:
 364:keyboards/ergodox/ez/matrix.c ****                 DDRB  |= (1<<3);
 452               		.loc 1 364 0
 453 00c0 239A      		sbi 0x4,3
 365:keyboards/ergodox/ez/matrix.c ****                 PORTB &= ~(1<<3);
 454               		.loc 1 365 0
 455 00c2 2B98      		cbi 0x5,3
 456 00c4 00C0      		rjmp .L25
 457               	.L35:
 366:keyboards/ergodox/ez/matrix.c ****                 break;
 367:keyboards/ergodox/ez/matrix.c ****             case 11:
 368:keyboards/ergodox/ez/matrix.c ****                 DDRD  |= (1<<2);
 458               		.loc 1 368 0
 459 00c6 529A      		sbi 0xa,2
 460 00c8 00C0      		rjmp .L62
 461               	.L34:
 369:keyboards/ergodox/ez/matrix.c ****                 PORTD &= ~(1<<3);
 370:keyboards/ergodox/ez/matrix.c ****                 break;
 371:keyboards/ergodox/ez/matrix.c ****             case 12:
 372:keyboards/ergodox/ez/matrix.c ****                 DDRD  |= (1<<3);
 462               		.loc 1 372 0
 463 00ca 539A      		sbi 0xa,3
 464               	.L62:
 373:keyboards/ergodox/ez/matrix.c ****                 PORTD &= ~(1<<3);
 465               		.loc 1 373 0
 466 00cc 5B98      		cbi 0xb,3
 467 00ce 00C0      		rjmp .L25
 468               	.L36:
 374:keyboards/ergodox/ez/matrix.c ****                 break;
 375:keyboards/ergodox/ez/matrix.c ****             case 13:
 376:keyboards/ergodox/ez/matrix.c ****                 DDRC  |= (1<<6);
 469               		.loc 1 376 0
 470 00d0 3E9A      		sbi 0x7,6
 377:keyboards/ergodox/ez/matrix.c ****                 PORTC &= ~(1<<6);
 471               		.loc 1 377 0
 472 00d2 4698      		cbi 0x8,6
 473               	.L25:
 474               	.LVL26:
 475               	.LBE27:
 476               	.LBE28:
 477               	.LBB29:
 478               	.LBB30:
 479               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 480               		.loc 2 245 0
 481 00d4 80EA      		ldi r24,lo8(-96)
 482 00d6 8A95      	1:	dec r24
 483 00d8 01F4      		brne 1b
 484               	.LVL27:
 485               	.LBE30:
 486               	.LBE29:
 487               	.LBB31:
 488               	.LBB32:
 268:keyboards/ergodox/ez/matrix.c ****         if (mcp23018_status) { // if there was an error
 489               		.loc 1 268 0
 490 00da C730      		cpi r28,7
 491 00dc D105      		cpc r29,__zero_reg__
 492 00de 00F4      		brsh .L37
 269:keyboards/ergodox/ez/matrix.c ****             return 0;
 493               		.loc 1 269 0
 494 00e0 8091 0000 		lds r24,mcp23018_status
 495 00e4 8111      		cpse r24,__zero_reg__
 496 00e6 00C0      		rjmp .L54
 497               	.LVL28:
 498               	.LBB33:
 273:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 499               		.loc 1 273 0
 500 00e8 80E4      		ldi r24,lo8(64)
 501 00ea 0E94 0000 		call i2c_start
 502               	.LVL29:
 503 00ee 8093 0000 		sts mcp23018_status,r24
 504 00f2 8823      		tst r24
 505 00f4 01F0      		breq .L39
 506               	.L41:
 272:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
 507               		.loc 1 272 0
 508 00f6 B12C      		mov r11,__zero_reg__
 509 00f8 00C0      		rjmp .L40
 510               	.L39:
 274:keyboards/ergodox/ez/matrix.c ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 511               		.loc 1 274 0
 512 00fa 83E1      		ldi r24,lo8(19)
 513 00fc 0E94 0000 		call i2c_write
 514               	.LVL30:
 515 0100 8093 0000 		sts mcp23018_status,r24
 516 0104 8111      		cpse r24,__zero_reg__
 517 0106 00C0      		rjmp .L41
 275:keyboards/ergodox/ez/matrix.c ****             data = i2c_readNak();
 518               		.loc 1 275 0
 519 0108 81E4      		ldi r24,lo8(65)
 520 010a 0E94 0000 		call i2c_start
 521               	.LVL31:
 522 010e 8093 0000 		sts mcp23018_status,r24
 523 0112 8111      		cpse r24,__zero_reg__
 524 0114 00C0      		rjmp .L41
 276:keyboards/ergodox/ez/matrix.c ****             data = ~data;
 525               		.loc 1 276 0
 526 0116 0E94 0000 		call i2c_readNak
 527               	.LVL32:
 277:keyboards/ergodox/ez/matrix.c ****         out:
 528               		.loc 1 277 0
 529 011a B82E      		mov r11,r24
 530 011c B094      		com r11
 531               	.LVL33:
 532               	.L40:
 279:keyboards/ergodox/ez/matrix.c ****             return data;
 533               		.loc 1 279 0
 534 011e 0E94 0000 		call i2c_stop
 535               	.LVL34:
 280:keyboards/ergodox/ez/matrix.c ****         }
 536               		.loc 1 280 0
 537 0122 8B2D      		mov r24,r11
 538 0124 00C0      		rjmp .L38
 539               	.LVL35:
 540               	.L37:
 541               	.LBE33:
 285:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 542               		.loc 1 285 0
 543 0126 8FB1      		in r24,0xf
 544 0128 8170      		andi r24,lo8(1)
 545 012a 8D25      		eor r24,r13
 284:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 546               		.loc 1 284 0
 547 012c 7999      		sbic 0xf,1
 548 012e 00C0      		rjmp .L55
 549 0130 92E0      		ldi r25,lo8(2)
 550 0132 00C0      		rjmp .L42
 551               	.L55:
 552 0134 90E0      		ldi r25,0
 553               	.L42:
 554 0136 892B      		or r24,r25
 555 0138 7C99      		sbic 0xf,4
 556 013a 00C0      		rjmp .L56
 557 013c 24E0      		ldi r18,lo8(4)
 558 013e 00C0      		rjmp .L43
 559               	.L56:
 560 0140 20E0      		ldi r18,0
 561               	.L43:
 562 0142 822B      		or r24,r18
 563 0144 7D99      		sbic 0xf,5
 564 0146 00C0      		rjmp .L57
 565 0148 28E0      		ldi r18,lo8(8)
 566 014a 00C0      		rjmp .L44
 567               	.L57:
 568 014c 20E0      		ldi r18,0
 569               	.L44:
 570 014e 822B      		or r24,r18
 571 0150 7E99      		sbic 0xf,6
 572 0152 00C0      		rjmp .L58
 573 0154 90E1      		ldi r25,lo8(16)
 574 0156 00C0      		rjmp .L45
 575               	.L58:
 576 0158 90E0      		ldi r25,0
 577               	.L45:
 578 015a 892B      		or r24,r25
 290:keyboards/ergodox/ez/matrix.c ****     }
 579               		.loc 1 290 0
 580 015c 9FB1      		in r25,0xf
 284:keyboards/ergodox/ez/matrix.c ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 581               		.loc 1 284 0
 582 015e 9095      		com r25
 583 0160 991F      		rol r25
 584 0162 9927      		clr r25
 585 0164 991F      		rol r25
 586 0166 9295      		swap r25
 587 0168 990F      		lsl r25
 588 016a 907E      		andi r25,lo8(-32)
 589 016c 892B      		or r24,r25
 590 016e 00C0      		rjmp .L38
 591               	.L54:
 270:keyboards/ergodox/ez/matrix.c ****         } else {
 592               		.loc 1 270 0
 593 0170 80E0      		ldi r24,0
 594               	.L38:
 595               	.LBE32:
 596               	.LBE31:
 182:keyboards/ergodox/ez/matrix.c ****             matrix_debouncing[i] = cols;
 597               		.loc 1 182 0
 598 0172 F801      		movw r30,r16
 599 0174 9081      		ld r25,Z
 600 0176 9817      		cp r25,r24
 601 0178 01F0      		breq .L47
 183:keyboards/ergodox/ez/matrix.c ****             if (debouncing) {
 602               		.loc 1 183 0
 603 017a 8083      		st Z,r24
 187:keyboards/ergodox/ez/matrix.c ****         }
 604               		.loc 1 187 0
 605 017c C092 0000 		sts debouncing,r12
 606               	.L47:
 189:keyboards/ergodox/ez/matrix.c ****     }
 607               		.loc 1 189 0 discriminator 2
 608 0180 0E94 0000 		call unselect_rows
 609               	.LVL36:
 610 0184 2196      		adiw r28,1
 611               	.LVL37:
 612 0186 0F5F      		subi r16,-1
 613 0188 1F4F      		sbci r17,-1
 614               	.LBE24:
 178:keyboards/ergodox/ez/matrix.c ****         select_row(i);
 615               		.loc 1 178 0 discriminator 2
 616 018a CE30      		cpi r28,14
 617 018c D105      		cpc r29,__zero_reg__
 618 018e 01F0      		breq .+2
 619 0190 00C0      		rjmp .L48
 620               	.LBE23:
 192:keyboards/ergodox/ez/matrix.c ****         if (--debouncing) {
 621               		.loc 1 192 0
 622 0192 8091 0000 		lds r24,debouncing
 623 0196 8823      		tst r24
 624 0198 01F0      		breq .L50
 193:keyboards/ergodox/ez/matrix.c ****             wait_us(1);
 625               		.loc 1 193 0
 626 019a 8150      		subi r24,lo8(-(-1))
 627 019c 8093 0000 		sts debouncing,r24
 628 01a0 8823      		tst r24
 629 01a2 01F0      		breq .L51
 630               	.LVL38:
 631               	.LBB34:
 632               	.LBB35:
 633               		.loc 2 245 0
 634 01a4 F5E0      		ldi r31,lo8(5)
 635 01a6 FA95      	1:	dec r31
 636 01a8 01F4      		brne 1b
 637 01aa 0000      		nop
 638 01ac 00C0      		rjmp .L50
 639               	.LVL39:
 640               	.L51:
 641 01ae A0E0      		ldi r26,lo8(matrix)
 642 01b0 B0E0      		ldi r27,hi8(matrix)
 643               	.LBE35:
 644               	.LBE34:
 193:keyboards/ergodox/ez/matrix.c ****             wait_us(1);
 645               		.loc 1 193 0
 646 01b2 E0E0      		ldi r30,lo8(matrix_debouncing)
 647 01b4 F0E0      		ldi r31,hi8(matrix_debouncing)
 648 01b6 CF01      		movw r24,r30
 649 01b8 825F      		subi r24,lo8(-(14))
 650               	.L52:
 651               	.LVL40:
 652               	.LBB36:
 198:keyboards/ergodox/ez/matrix.c ****             }
 653               		.loc 1 198 0 discriminator 3
 654 01ba 9191      		ld r25,Z+
 655               	.LVL41:
 656 01bc 9D93      		st X+,r25
 657               	.LVL42:
 197:keyboards/ergodox/ez/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 658               		.loc 1 197 0 discriminator 3
 659 01be 8E13      		cpse r24,r30
 660 01c0 00C0      		rjmp .L52
 661               	.LVL43:
 662               	.L50:
 663               	.LBE36:
 203:keyboards/ergodox/ez/matrix.c **** 
 664               		.loc 1 203 0
 665 01c2 0E94 0000 		call matrix_scan_quantum
 666               	.LVL44:
 206:keyboards/ergodox/ez/matrix.c **** 
 667               		.loc 1 206 0
 668 01c6 81E0      		ldi r24,lo8(1)
 669               	/* epilogue start */
 670 01c8 DF91      		pop r29
 671 01ca CF91      		pop r28
 672               	.LVL45:
 673 01cc 1F91      		pop r17
 674 01ce 0F91      		pop r16
 675 01d0 FF90      		pop r15
 676 01d2 EF90      		pop r14
 677 01d4 DF90      		pop r13
 678 01d6 CF90      		pop r12
 679 01d8 BF90      		pop r11
 680 01da 0895      		ret
 681               		.cfi_endproc
 682               	.LFE132:
 684               		.section	.text.matrix_is_modified,"ax",@progbits
 685               	.global	matrix_is_modified
 687               	matrix_is_modified:
 688               	.LFB133:
 209:keyboards/ergodox/ez/matrix.c ****     if (debouncing) return false;
 689               		.loc 1 209 0
 690               		.cfi_startproc
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 0 */
 694               	.L__stack_usage = 0
 210:keyboards/ergodox/ez/matrix.c ****     return true;
 695               		.loc 1 210 0
 696 0000 81E0      		ldi r24,lo8(1)
 697 0002 9091 0000 		lds r25,debouncing
 698 0006 9111      		cpse r25,__zero_reg__
 699 0008 80E0      		ldi r24,0
 700               	.L64:
 212:keyboards/ergodox/ez/matrix.c **** 
 701               		.loc 1 212 0
 702 000a 0895      		ret
 703               		.cfi_endproc
 704               	.LFE133:
 706               		.section	.text.matrix_is_on,"ax",@progbits
 707               	.global	matrix_is_on
 709               	matrix_is_on:
 710               	.LFB134:
 216:keyboards/ergodox/ez/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 711               		.loc 1 216 0
 712               		.cfi_startproc
 713               	.LVL46:
 714               	/* prologue: function */
 715               	/* frame size = 0 */
 716               	/* stack size = 0 */
 717               	.L__stack_usage = 0
 217:keyboards/ergodox/ez/matrix.c **** }
 718               		.loc 1 217 0
 719 0000 E82F      		mov r30,r24
 720 0002 F0E0      		ldi r31,0
 721 0004 E050      		subi r30,lo8(-(matrix))
 722 0006 F040      		sbci r31,hi8(-(matrix))
 723 0008 2081      		ld r18,Z
 724 000a 822F      		mov r24,r18
 725               	.LVL47:
 726 000c 90E0      		ldi r25,0
 727 000e 21E0      		ldi r18,lo8(1)
 728 0010 30E0      		ldi r19,0
 729 0012 00C0      		rjmp 2f
 730               		1:
 731 0014 220F      		lsl r18
 732 0016 331F      		rol r19
 733               		2:
 734 0018 6A95      		dec r22
 735 001a 02F4      		brpl 1b
 736 001c 2823      		and r18,r24
 737 001e 3923      		and r19,r25
 738 0020 81E0      		ldi r24,lo8(1)
 739 0022 232B      		or r18,r19
 740 0024 01F4      		brne .L69
 741 0026 80E0      		ldi r24,0
 742               	.L69:
 218:keyboards/ergodox/ez/matrix.c **** 
 743               		.loc 1 218 0
 744 0028 0895      		ret
 745               		.cfi_endproc
 746               	.LFE134:
 748               		.section	.text.matrix_get_row,"ax",@progbits
 749               	.global	matrix_get_row
 751               	matrix_get_row:
 752               	.LFB135:
 222:keyboards/ergodox/ez/matrix.c ****     return matrix[row];
 753               		.loc 1 222 0
 754               		.cfi_startproc
 755               	.LVL48:
 756               	/* prologue: function */
 757               	/* frame size = 0 */
 758               	/* stack size = 0 */
 759               	.L__stack_usage = 0
 223:keyboards/ergodox/ez/matrix.c **** }
 760               		.loc 1 223 0
 761 0000 E82F      		mov r30,r24
 762 0002 F0E0      		ldi r31,0
 763 0004 E050      		subi r30,lo8(-(matrix))
 764 0006 F040      		sbci r31,hi8(-(matrix))
 224:keyboards/ergodox/ez/matrix.c **** 
 765               		.loc 1 224 0
 766 0008 8081      		ld r24,Z
 767               	.LVL49:
 768 000a 0895      		ret
 769               		.cfi_endproc
 770               	.LFE135:
 772               		.section	.text.matrix_print,"ax",@progbits
 773               	.global	matrix_print
 775               	matrix_print:
 776               	.LFB136:
 227:keyboards/ergodox/ez/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 777               		.loc 1 227 0
 778               		.cfi_startproc
 779               	/* prologue: function */
 780               	/* frame size = 0 */
 781               	/* stack size = 0 */
 782               	.L__stack_usage = 0
 783               	.LVL50:
 784 0000 0895      		ret
 785               		.cfi_endproc
 786               	.LFE136:
 788               		.section	.text.matrix_key_count,"ax",@progbits
 789               	.global	matrix_key_count
 791               	matrix_key_count:
 792               	.LFB137:
 237:keyboards/ergodox/ez/matrix.c ****     uint8_t count = 0;
 793               		.loc 1 237 0
 794               		.cfi_startproc
 237:keyboards/ergodox/ez/matrix.c ****     uint8_t count = 0;
 795               		.loc 1 237 0
 796 0000 0F93      		push r16
 797               	.LCFI9:
 798               		.cfi_def_cfa_offset 3
 799               		.cfi_offset 16, -2
 800 0002 1F93      		push r17
 801               	.LCFI10:
 802               		.cfi_def_cfa_offset 4
 803               		.cfi_offset 17, -3
 804 0004 CF93      		push r28
 805               	.LCFI11:
 806               		.cfi_def_cfa_offset 5
 807               		.cfi_offset 28, -4
 808 0006 DF93      		push r29
 809               	.LCFI12:
 810               		.cfi_def_cfa_offset 6
 811               		.cfi_offset 29, -5
 812               	/* prologue: function */
 813               	/* frame size = 0 */
 814               	/* stack size = 4 */
 815               	.L__stack_usage = 4
 816               	.LVL51:
 237:keyboards/ergodox/ez/matrix.c ****     uint8_t count = 0;
 817               		.loc 1 237 0
 818 0008 C0E0      		ldi r28,lo8(matrix)
 819 000a D0E0      		ldi r29,hi8(matrix)
 238:keyboards/ergodox/ez/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 820               		.loc 1 238 0
 821 000c 10E0      		ldi r17,0
 822 000e 0C2F      		mov r16,r28
 823 0010 025F      		subi r16,lo8(-(14))
 824               	.LVL52:
 825               	.L73:
 826               	.LBB37:
 240:keyboards/ergodox/ez/matrix.c ****     }
 827               		.loc 1 240 0 discriminator 3
 828 0012 8991      		ld r24,Y+
 829               	.LVL53:
 830 0014 90E0      		ldi r25,0
 831 0016 0E94 0000 		call bitpop16
 832               	.LVL54:
 833 001a 180F      		add r17,r24
 834               	.LVL55:
 239:keyboards/ergodox/ez/matrix.c ****         count += bitpop16(matrix[i]);
 835               		.loc 1 239 0 discriminator 3
 836 001c 0C13      		cpse r16,r28
 837 001e 00C0      		rjmp .L73
 838               	.LBE37:
 243:keyboards/ergodox/ez/matrix.c **** 
 839               		.loc 1 243 0
 840 0020 812F      		mov r24,r17
 841               	/* epilogue start */
 842 0022 DF91      		pop r29
 843 0024 CF91      		pop r28
 844               	.LVL56:
 845 0026 1F91      		pop r17
 846               	.LVL57:
 847 0028 0F91      		pop r16
 848 002a 0895      		ret
 849               		.cfi_endproc
 850               	.LFE137:
 852               		.section	.bss.mcp23018_reset_loop,"aw",@nobits
 855               	mcp23018_reset_loop:
 856 0000 00        		.zero	1
 857               		.section	.bss.matrix_debouncing,"aw",@nobits
 860               	matrix_debouncing:
 861 0000 0000 0000 		.zero	14
 861      0000 0000 
 861      0000 0000 
 861      0000 
 862               		.section	.bss.matrix,"aw",@nobits
 865               	matrix:
 866 0000 0000 0000 		.zero	14
 866      0000 0000 
 866      0000 0000 
 866      0000 
 867               		.section	.data.debouncing,"aw",@progbits
 870               	debouncing:
 871 0000 05        		.byte	5
 872               		.text
 873               	.Letext0:
 874               		.file 3 "/usr/lib/avr/include/stdint.h"
 875               		.file 4 "./tmk_core/common/matrix.h"
 876               		.file 5 "./tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/USBTask.h"
 877               		.file 6 "keyboards/ergodox/ez/ez.h"
 878               		.file 7 "keyboards/ergodox/ez/i2cmaster.h"
 879               		.file 8 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccp6mgpW.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccp6mgpW.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccp6mgpW.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccp6mgpW.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccp6mgpW.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccp6mgpW.s:12     .text.init_cols:0000000000000000 init_cols
     /tmp/ccp6mgpW.s:35     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/ccp6mgpW.s:98     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccp6mgpW.s:113    .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccp6mgpW.s:128    .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccp6mgpW.s:145    .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccp6mgpW.s:162    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccp6mgpW.s:179    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccp6mgpW.s:196    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccp6mgpW.s:860    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccp6mgpW.s:865    .bss.matrix:0000000000000000 matrix
     /tmp/ccp6mgpW.s:242    .text.matrix_power_up:0000000000000000 matrix_power_up
     /tmp/ccp6mgpW.s:288    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccp6mgpW.s:855    .bss.mcp23018_reset_loop:0000000000000000 mcp23018_reset_loop
     /tmp/ccp6mgpW.s:870    .data.debouncing:0000000000000000 debouncing
     /tmp/ccp6mgpW.s:687    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccp6mgpW.s:709    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccp6mgpW.s:751    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccp6mgpW.s:775    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccp6mgpW.s:791    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
mcp23018_status
i2c_start
i2c_write
i2c_stop
init_mcp23018
ergodox_blink_all_leds
i2c_readNak
matrix_scan_quantum
bitpop16
__do_copy_data
__do_clear_bss
